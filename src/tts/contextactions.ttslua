
function addObjectsActions()
  for index, object in ipairs(getObjects()) do
    if getPiece(object) then
      addPieceActions(object)
    elseif isBoard(object) then
      addBoardActions(object)
    end
  end
end

function addPieceActions(obj)

  function squareAlign(color, pos, focusedObj)
    local objects = Player[color].getSelectedObjects()
    inplaceShuffle(objects)
    local spacing = getPieceSpacing(objects, true)

    local p0 = focusedObj.getPosition()
    local width = math.ceil(math.sqrt(#objects))

    for i, obj in ipairs(objects) do
      setPieceCenter(obj, {
        p0.x + (i - 1) % width * spacing,
        p0.y,
        p0.z - math.floor((i - 1) / width) * spacing
      }, false)
    end
  end
  obj.addContextMenuItem("Arrange: Square", squareAlign)

  function rowAlign(color, pos, focusedObj)
    local objects = Player[color].getSelectedObjects()
    inplaceShuffle(objects)
    local spacing = getPieceSpacing(objects, false)

    local p0 = focusedObj.getPosition()

    for i, obj in ipairs(objects) do
      setPieceCenter(obj, {p0.x + (i - 1) * spacing, p0.y, p0.z}, false)
    end
  end
  obj.addContextMenuItem("Arrange: Row", rowAlign)

  function gridAlign(color, pos, focusedObj)
    local objects = Player[color].getSelectedObjects()
    local spacing = getPieceSpacing(objects, true)
    local origin = Vector(pos)

    for i, obj in ipairs(objects) do
      p = obj.getPosition()
      p.x = math.floor((p.x - origin.x) / spacing + .5) * spacing + origin.x
      p.z = math.floor((p.z - origin.z) / spacing + .5) * spacing + origin.z
      setPieceCenter(obj, p, false)
    end
  end
  obj.addContextMenuItem("Align: To grid", gridAlign)

  function solveAlign(color, pos, focusedObj)
    local objects = Player[color].getSelectedObjects()

    for i, obj in ipairs(objects) do
      local piece = getPiece(obj)
      if piece then
        obj.setRotationSmooth(piece.solutionRotation)
      end
    end

    broadcastToAll("Cheat: " .. Player[color].steam_name .. " rotated " .. #objects .. " piece(s) the right way.")
  end
  obj.addContextMenuItem("Cheat: Rotate Right", solveAlign)
end

function addBoardActions(board)
  function changeTableColor(color, pos, focusedObj)
    function colorPicked(pickedColor, playerColor)
      for i, obj in pairs(tableSurfaces) do
        local settings = obj.getCustomObject()
        settings.diffuse = ""
        obj.setCustomObject(settings)

        obj.setColorTint(pickedColor)

        tableSurfaces[i] = obj.reload()
        tableSurfaces[i].interactable = false
      end
    end
    Player[color].showColorDialog(tableSurfaces[0].getColorTint(), colorPicked)
  end
  board.addContextMenuItem("Change table color", changeTableColor)


  function selectEdges(color, pos, focusedObj)
    Player[color].clearSelectedObjects()

    local edgeObjects = {}

    for pieceId, info in pairs(templateData[gameState.templateId].pieces) do
      if #info.neighbors <= 5 and gameState.pieces[pieceId].joinedTo == nil then
        local piece = getPiece(pieceId)
        if piece and piece.object ~= nil and piece.object.locked == false then
          table.insert(edgeObjects, piece.object)
        end
      end
    end

    inplaceShuffle(edgeObjects)
    for i, object in ipairs(edgeObjects) do
      object.addToPlayerSelection(color)
    end

    broadcastToAll("Cheat: " .. Player[color].steam_name .. " selected edges.")
  end
  board.addContextMenuItem("Cheat: Select edges", selectEdges)

  local lastPiecePick = nil
  function gatherPieces(color, pos, focusedObj)
    -- todo: may only work right for rectangular puzzles
    local player = Player[color]

    --Try to figure out where on the puzzle they clicked
    --Wait, no, it's not useful because the pointer is already not where they opened the context menu,
    --but where they clicked onthe menu.
    --[[local pointerPos = player.getPointerPosition()
    local bounds = focusedObj.getBoundsNormalized()
    bounds.left = bounds.center.x - bounds.size.x / 2
    bounds.right = bounds.center.x + bounds.size.x / 2
    bounds.far = bounds.center.z + bounds.size.z / 2
    bounds.near = bounds.center.z - bounds.size.z / 2

    local puzzlePos = {
      x = (pointerPos.x - bounds.left) / bounds.size.x,
      y = (pointerPos.z - bounds.near) / bounds.size.z,
    }

    log("Pointer is at " .. printTable(pointerPos, true))
    log("Bounds are " .. printTable(bounds, true))
    log("puzzlePos " .. printTable(puzzlePos, true)) ]]

    local bounds = focusedObj.getBounds()

    local hits = Physics.cast({
      origin = bounds.center,
      direction = focusedObj.getTransformUp(),
      type = 3,--box
      size = bounds.size,
      -- debug = true,
    })

    local piece = nil
    for i, hit in ipairs(hits) do
      if getPiece(hit.hit_object) then
        piece = getPiece(hit.hit_object)
      end
    end


    if not piece then
      player.showInfoDialog("Place a piece on top of the puzzle")
    else
      lastPiecePick = piece
      -- log("regarding piece at " .. printTable(lastPiecePick.solutionPosition, true))
      player.showInputDialog("Collect how far from this piece?", "10", countConfirmed)
    end

    function countConfirmed(text, color)
      local range = text + 0
      local rangeSq = range * range
      -- log("piece at " .. printTable(lastPiecePick.solutionPosition, true))

      Player[color].clearSelectedObjects()

      local targetPos = lastPiecePick.solutionPosition
      local count = 0
      for i, piece in ipairs(getAllPieces()) do
        local distSq = math.pow(piece.solutionPosition.x - targetPos.x, 2) + math.pow(piece.solutionPosition.z - targetPos.z, 2)
        if distSq <= rangeSq and not piece.object.locked then
          -- log("piece at " .. printTable(piece, true) .. " is " .. distSq .. " <= " .. rangeSq)
          -- piece.object.addToPlayerSelection(color)
          piece.object.setPosition({
            (math.random() - .5) * range,
            math.random() * range + 2,
            (math.random() - .5) * range,
          }, true)
          piece.object.setVelocity({0, math.random() * 2, 0})
          count = count + 1
        end
      end

      broadcastToAll("Cheat: " .. Player[color].steam_name .. " gathered " .. count .. " piece(s).")
    end
  end
  board.addContextMenuItem("Cheat: Gather pieces", gatherPieces)


end

