--[[ Lua code. See documentation: http://berserk-games.com/knowledgebase/scripting/ --]]
templateData = {}
puzzleData = {}
PUZZLE_URL = 'https://raw.githubusercontent.com/Canonelis/ttsjiggys/main/'
checkSolution_waitId = nil
showing_credits = false
update_scoreboard_delay = nil

-- help score
-- lua getPlayerState("").score = 10
------------
-- TTS Hooks
------------

gameState = {}
saveDelay = false
function onLoad(save_state)
  local start = os.time()

  if save_state == '' or save_state == "saveDelay" then
    if save_state == '' then
      saveDelay = true
    end

    gameState = {
      puzzleEnabled = true,
      adminControl = false,
      debug_level = 0,
      -- 0: debugging off
      -- 1: specific function debugging
      -- 2: infrequent function calls or small reports
      -- 3: includes frequent function calls
      -- 4: display everything
      -- 99:if a debug message has this level it won't display
      duration = 0,
      players = {},
      teams = {}
      --pieces = {},
      --guidCatalog = {},
      --templateId = nil,
      --pieceLabel = nil,
      --pictureUrl = nil
    }
  else
    gameState = JSON.decode(save_state)
    gameState.debug_level = 0
    if gameState.debug_level >= 2 then
      debugPrint(string.format(
        'onLoad-JSONLoad elapsed: %.2f',
        os.time() - start
      ))
    end
  end

  if gameState.templateId then
    generatePieceData(templateData[gameState.templateId])
  end

  if gameState.pieceLabel == nil then
    gameState.pieceLabel = next(pieceTypeList)
  end

  populateDynamicUI()
  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'onLoad-PopulateDynamicUI elapsed: %.2f',
      os.time() - start
    ))
  end

  Wait.frames(function()
    setPuzzleEnabled(gameState.puzzleEnabled)
    setAdminControl(gameState.adminControl)

    if getHostPlayer().steam_name == "BandedOtter" then
      UI.setAttribute('debug_level', 'visibility', 'Host')
    end
    if gameState.debug_level == 0 then
      UI.setAttribute('debug_level', 'text', "Debugging Off")
    else
      UI.setAttribute('debug_level', 'text', "Debug Level "..tostring(gameState.debug_level))
    end
  end, 2)

  Wait.time(onWaitMain, 1, -1)

  Physics.play_area = 2.5

  if tableSurfaces ~= nil then
    for i,v in pairs(tableSurfaces) do
      if v ~= nil and v ~= tableSurface then
        v.destruct()
      end
    end
  end
  tableSurface = getObjectFromGUID("1f2767")
  if tableSurface ~= nil then
    tableSurfaces = {}
    tableSurface.setCustomObject({
      mesh = "http://cloud-3.steamusercontent.com/ugc/1701784456924019297/E6BD6A9D7C6C935C2281036FA5535123AE6C4C49/"
    })
    tableSurface.locked = true
    tableSurface.interactable = false
    sv = tableSurface.getVectorLines({})
    tableSurface.setVectorLines({})
    tableSurface = tableSurface.reload()
    Wait.frames(function()
          local wid = 98
          for i = 0, 5 do
            xi = i % 3
            yi = math.floor(i/3)
            tableSurfaces[i] = tableSurface.clone({position={ -wid + wid * xi, 0.01, -wid/2 + wid * yi}})
            tableSurfaces[i].setRotation({0,0,0})
            tableSurfaces[i].interactable = false
          end
          tableSurface.destruct()
          tableSurface = tableSurfaces[0]
          for _,p1 in pairs(sv) do
            for _, p2 in pairs(p1.points) do
              p2.y = 2
            end
          end
          Global.setVectorLines(sv)
        end, 5)
  else
    tableSurfaces = {}
    for _,o in pairs(getObjects()) do
      local customObj = o.getCustomObject()
      if customObj and customObj.mesh and customObj.mesh:match("123AE6C4C49") then
        table.insert(tableSurfaces,o)
        o.interactable = false
      end
    end
    table.sort(tableSurfaces,
            function(a,b)
              apos = a.getPosition()
              bpos = b.getPosition()
              if math.abs(apos.z-bpos.z) > 1 then
                return apos.z < bpos.z
              end
              return apos.x < bpos.x
            end)
    for i = 1, 6 do
      tableSurfaces[i-1] = tableSurfaces[i]
      tableSurfaces[i] = nil
    end
  end
  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'onLoad-TableSurfaces elapsed: %.2f',
      os.time() - start
    ))
  end

  -- freeze solution boards in place
  for _, object in ipairs(getObjects()) do
    if isBoard(object) then
      object.locked = true
      object.interactable = true
    end
  end

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'onLoad elapsed: %.2f',
      os.time() - start
    ))
  end
end

function onSave()
  if saveDelay then
    return 'saveDelay'
  end
  if not gameState.puzzleEnabled then return end

  local start = os.time()

  --local gameStateJSON = JSON.encode(gameState)
  local gameStateJSON = serializeGameStateJSON()

  if gameState.debug_level >= 3 then
    debugPrint(string.format(
      'onSave elapsed: %.2f, gameStateJSON.len: %d',
      os.time() - start,
      string.len(gameStateJSON)
    ))
  end
  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'onSave gameStateJSON: %s',
      gameStateJSON
    ))
  end
  return gameStateJSON
end

function setPuzzleEnabled(value)
  gameState.puzzleEnabled = value
  UI.setAttribute('puzzleEnabled', 'isOn', value)
  UI.setAttribute('puzzleEnabled_' .. tostring(value), 'active', true)
  UI.setAttribute('puzzleEnabled_' .. tostring(not value), 'active', false)
end

function setAdminControl(value)
  gameState.adminControl = value
  UI.setAttribute('adminControl', 'isOn', value)
  UI.setAttribute('puzzleEnabled', 'visibility', value and "Admin" or "Host")
  UI.setAttribute('puzzleControls', 'visibility', value and "Admin" or "Host")
  UI.setAttribute('closeCredits', 'visibility', value and "Admin" or "Host")
  UI.setAttribute('puzzleSelector', 'visibility', value and "Admin" or "Host")
  UI.setAttribute('pictureUrlChanger', 'visibility', value and "Admin" or "Host")
  UI.setAttribute('adminControl_' .. tostring(value), 'active', true)
  UI.setAttribute('adminControl_' .. tostring(not value), 'active', false)
end

function printTable(t,return_as_string,table_id_list)
	local s
	return_as_string = return_as_string == true -- default is false
	if table_id_list == nil then -- used if table has been seen before. don't display it again
		table_id_list = {}
	end
	if type(t) == "nil" or type(t) == "boolean" then
		s = string.upper(tostring(t))
	elseif type(t) == "number" or type(t) == "function" then
		s = tostring(t)
	elseif type(t) == "table" and table_id_list[t] == nil then
    table_id_list[t] = true
    local strings_list = {}
    for i, v in pairs(t) do
      table.insert(strings_list,tostring(i)..":"..printTable(v,true,table_id_list))
    end
    s = "{"..table.concat(strings_list,",").."}"
	else
		s = '"'..tostring(t)..'"'
	end
	if return_as_string then
		return s
	else
		return print(""..string.gsub(s,"%[([0-9A-Fa-f][0-9A-Fa-f]+)%]","[#%1]"))
	end
end

-- this is 300% faster than JSON.encode(gameState) without caching
pieceTextCache = ''
function serializeGameStateJSON()
  local player_names = {}
  local player_names_dict = {}
  
  
  local players = {}
  for playerName, playerData in pairs(gameState.players) do
    players[#players + 1] = string.format(
      '"%s":{"duration":%d,"score":%d}',
      string.gsub(playerName, '\\', '\\\\'):gsub('"', '\\"'),
      playerData.duration,
      playerData.score
    )
  end

  local teams = {}
  for teamName, teamData in pairs(gameState.teams) do
    teams[#teams + 1] = string.format(
      '"%s":{"duration":%d,"score":%d}',
      teamName,
      teamData.duration,
      teamData.score
    )
  end
  local pieceText = ''
  if gameState.pieces ~= nil then
    if pieceTextCache ~= '' then
      pieceText = pieceTextCache
    else
      local pieces = {}
      for index, pieceData in ipairs(gameState.pieces or {}) do
        if pieceData.joinedTo == nil then
          pieces[#pieces + 1] = '[]'
        else
          pieces[#pieces + 1] = string.format(
            '{"joinedTo":%d,"parentId":%d,"player_name":"%s"}',
            pieceData.joinedTo,
            pieceData.parentId,
            string.gsub(pieceData.player_name, '\\', '\\\\'):gsub('"', '\\"')
          )
        end
      end
      pieceText = ',"pieces":[' .. table.concat(pieces, ',') .. ']'
      pieceTextCache = pieceText
    end
  end
  local guidCatalogText = ''
  if gameState.guidCatalog ~= nil then
    guidCatalogText = ',"guidCatalog":["' .. table.concat(gameState.guidCatalog, '","') .. '"]'
  end

  local templateText = ''
  if gameState.templateId ~= nil then
    templateText = ',"templateId":"' .. gameState.templateId .. '"'
  end

  local pictureUrlText = ''
  if gameState.pictureUrl ~= nil then
    pictureUrlText = ',"pictureUrl":' .. JSON.encode(gameState.pictureUrl)
  end

  local result = string.format(
    '{"puzzleEnabled":%s,"adminControl":%s,"debug_level":%d,"duration":%d,"players":{%s},"teams":{%s}%s%s%s%s}',
    tostring(gameState.puzzleEnabled),
    tostring(gameState.adminControl),
    tostring(gameState.debug_level),
    gameState.duration,
    table.concat(players, ','),
    table.concat(teams, ','),
    pieceText,
    guidCatalogText,
    templateText,
    pictureUrlText
  )

  return result
end

function onObjectRandomize(object, player_color)
  if not gameState.puzzleEnabled then return end

  local start = os.time()

  local randomizedPiece = getPiece(object)
  if randomizedPiece == nil then return end

  local pieceRotation = randomizedPiece.object.getRotation()
  pieceRotation.y = math.random(-180, 180)
  randomizedPiece.object.setRotationSmooth(pieceRotation)

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'onObjectRandomize player_color: %s, randomizedPiece.id: %d, elapsed: %.2f',
      player_color,
      randomizedPiece.id,
      os.time() - start
    ))
  end
end

lastDrop = {}
function onObjectDropped(player_color, object)
  if not gameState.puzzleEnabled or player_color == "Grey" then return end

  local start = os.time()

  local droppedPiece = getPiece(object)
  if droppedPiece == nil then return end

  -- if the piece is flipped then right it
  if droppedPiece.object.is_face_down then
    droppedPiece.object.flip()
  end

  -- this only checks the first piece of a batch move
  if lastDrop[player_color] == nil or lastDrop[player_color] < Time.frame_count then
    lastDrop[player_color] = Time.frame_count
    onPieceDropped(player_color, droppedPiece)
  end

  -- If the piece wasn't correct then stop it from rotating quickly and set it down at a 90 degree angle
  if object.getRotationSmooth() == nil then
    local a_vel = object.getAngularVelocity().y
    if math.abs(a_vel) > 3 then
      local new_rotation = math.floor(object.getRotation().y / 90) * 90 + ( a_vel > 0 and 90 or 0)
      object.setRotationSmooth({object.getRotation().x, new_rotation, object.getRotation().z}, true, true)
    end
  end


  if gameState.debug_level >= 3 then
    debugPrint(string.format(
      'onObjectDropped player_color: %s, droppedPiece.id: %d, lastDrop: %s, elapsed: %.2f',
      player_color,
      droppedPiece.id,
      tostring(lastDrop[player_color]),
      os.time() - start
    ))
  end
end

function getHostPlayer()
  for index, player in ipairs(Player.getPlayers()) do
    if player.host then
      return player
    end
  end
end
function findInArray(val,arr,cmp_func) --cmp_func is optional, a function with two arguments that returns a boolean value
  -- returns the index of the value in the table
  if type(arr) ~= "table" then
    return nil
  end
  if cmp_func ~= nil then
    if type(cmp_func) == "function" then
      for i, v in pairs(arr) do
        success, res = pcall(cmp_func,v,val)
        if success then
          if res == true then
            return i
          end
        else
          error("findInArray:custom compare function failed with error:"..tostring(res))
        end
      end
    else
      error("findInArray:custom compare function is not a function or does not have 2 arguments.")
    end
  else
    for i, v in pairs(arr) do
      if v == val then
        return i
      end
    end
  end
  return nil
end

function isInArray(val,arr,cmp_func) --cmp_func is optional
  return findInArray(val,arr,cmp_func) ~= nil
end

function areDiagonals(pId1, pId2)
  if gameState.templateId ~= nil then
    pos1 = templateData[gameState.templateId].pieces[pId1].solutionPosition
    pos2 = templateData[gameState.templateId].pieces[pId2].solutionPosition
    return math.abs(pos1.x - pos2.x) > 0.5 and math.abs(pos1.x - pos2.x) < 1.5 and math.abs(pos1.z - pos2.z) > 0.5 and math.abs(pos1.z - pos2.z) < 1.5
  end
  return false
end

function onPlayerAction(player, action, objects)
  if player.color ~= "Grey" and not player.admin then
    if action == Player.Action.Select then
      return checkPlayerSelection(player, objects)
    elseif isInArray(action, {
      Player.Action.PickUp,
      Player.Action.RotateIncrementalLeft,
      Player.Action.RotateIncrementalRight,
      Player.Action.RotateOver,
      Player.Action.FlipIncrementalLeft,
      Player.Action.FlipIncrementalRight,
      Player.Action.FlipOver,
      Player.Action.Group,
      Player.Action.Randomize,
      Player.Action.Under
    }) then
      local playerState = getPlayerState(player.steam_name)
      local playerAllowance = playerState.score + 1

      local handObjects = player.getHoldingObjects() or {}
      local selObjects = player.getSelectedObjects() or {}
      local handCount = handObjects == nil and 0 or #handObjects
      local selCount = selObjects == nil and 0 or #selObjects

      local objectCount = math.max(handCount,selCount) + (action == Player.Action.PickUp and handCount > 0 and 1 or 0)
      if objectCount > playerAllowance then
        for _, obj in pairs(selObjects) do
          obj.removeFromPlayerSelection(player.color)
        end
        for _, obj in pairs(handObjects) do
          obj.setVelocity({0,0,0})
          obj.setAngularVelocity({0,0,0})
          obj.drop()
        end
        local message = string.format(
          '%s, your score of %d only allows you to move %d piece'..(playerAllowance == 1 and "" or "s")..' simultaneously.'..(playerAllowance == 1 and " Join pieces together to get a higher score." or ""),
          player.steam_name,
          playerState.score,
          playerAllowance
          )
        broadcastToColor(message, player.color, Color.Red)
        local hostPlayer = getHostPlayer()
        broadcastToColor(message, hostPlayer.color, player.color)
        player.changeColor("Grey")
        return false
      end
    end
  end
end

lastPlayerWarning = {}
function checkPlayerSelection(player, objects)
  local start = os.time()

  -- Check the player's selection and reduce it if it is too high
  -- Must return a boolean since this function is also called by onPlayerAction()
  local shouldAllow = true
  if player.color ~= "Grey" and not player.admin then
    local playerState = getPlayerState(player.steam_name)
    local playerAllowance = playerState.score + 1
    local sel_objects = player.getSelectedObjects() or {}
    if objects ~= nil then
      if #sel_objects + #objects > playerAllowance then
        shouldAllow = false
      end
    elseif #sel_objects > playerAllowance then
      shouldAllow = false
      for i = #sel_objects, playerAllowance + 1, -1 do
        sel_objects[i].drop()
        sel_objects[i].removeFromPlayerSelection(player.color)
      end
    end
    if shouldAllow == false then
      local tmPlayerWarning = lastPlayerWarning[player.steam_name] or 0
      if Time.time - tmPlayerWarning > 5 then
        lastPlayerWarning[player.steam_name] = Time.time
        local message = string.format(
          '%s, your score of %d only allows you to move %d piece'..(playerAllowance == 1 and "" or "s")..' simultaneously.'..(playerAllowance == 1 and " Join pieces together to get a higher score." or ""),
          player.steam_name,
          playerState.score,
          playerAllowance
          )
        broadcastToColor(message, player.color, Color.Red)
        local hostPlayer = getHostPlayer()
        broadcastToColor(message, hostPlayer.color, player.color)
      end
    end
  end
  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'checkPlayerSelection player.color: %s, shouldAllow: %s, elapsed: %.2f',
      tostring(player.color),
      tostring(shouldAllow),
      os.time() - start
    ))
  end
  return shouldAllow
end

function onClick_CloseGreeting(player)
  local start = os.time()

  if player.team ~= 'Clubs' then
    player.team = 'Clubs'
  end

  debugPrint(string.format(
    'onClick_CloseGreeting, player.color: %s, player.team: %s, elapsed: %.2f',
    tostring(player.color),
    tostring(player.team),
    os.time() - start
  ))
end

function iterJoinedTo(pieceId,include_self)
  -- This iterator is safe against changing the returned value's data
  include_self = include_self ~= false -- Default is false
  local nextPieceId = gameState.pieces[pieceId].joinedTo
  local startPieceId = pieceId
  return function ()
            if include_self then
              include_self = false
              return pieceId
            end
            local ret = nextPieceId
            if ret ~= nil and ret ~= startPieceId then
              nextPieceId = gameState.pieces[ret].joinedTo
              return ret
            end
          end
end

---------------
-- UI Callbacks
---------------
function onEndEdit_puzzleUrl(player, value, id)
  UI.setAttribute(id, 'text', value)
end

function onEndEdit_newPictureUrl(player, value, id)
  UI.setAttribute(id, 'text', value)
end

function onValueChanged_templateSelection(player, value, id)
  UI.setAttribute(id, 'isOn', value)
  UI.setAttribute('templateSelection', 'selectedId', id)
end

function onEndEdit_puzzleTemplate(player, value, id)
  UI.setAttribute(id, 'text', value)
end

function onClick_TestNewFeature()
  function joinAllPiecesCoroutine()
    local allPieces = getAllPieces()

    local host_player = getHostPlayer()

    local mainPiece = nil
    for x = 1, #allPieces - 5 do
      local piece = allPieces[x]
      if mainPiece == nil then
        mainPiece = piece
      else
        joinPieces(host_player, piece, mainPiece)
      end
    end

    return 1
  end

  function placeAllPiecesCoroutine()
    local allPieces = getAllPieces()

    for x = 1, #allPieces do
      local piece = allPieces[x]
      local targetPosition = Vector(templateData[gameState.templateId].pieces[piece.id].solutionPosition)
      -- make sure we clear the board so physics doesn't explode
      targetPosition.y = targetPosition.y + 0.25
      piece.object.setRotation(piece.solutionRotation)
      piece.object.setPosition(targetPosition)
    end

    return 1
  end

  function addRandomPlayer()
    gameState.players['<Pl"&\'yer \\>\\"' .. math.random(1, 100)] = {
      score = math.random(1, 99999),
      duration = math.random(1, 99999)
    }
  end

  --addRandomPlayer()

  --startLuaCoroutine(self, 'joinAllPiecesCoroutine')
  startLuaCoroutine(self, 'placeAllPiecesCoroutine')
end

function onClick_CancelPuzzleSelector()
  UI.setAttribute('puzzleSelector', 'active', false)
end

function onClick_CancelNewPictureUrl()
  UI.setAttribute('pictureUrlChanger', 'active', false)
end

function findElementById(table, id)
  for index, element in ipairs(table) do
    if element.attributes.id == id then
      return element
    end
    if element.children then
      local found = findElementById(element.children, id)
      if found then
        return found
      end
    end
  end
end

function onClick_NewPuzzle()
  UI.setAttribute('puzzleSelector', 'active', true)
end

function populateDynamicUI()
  local uiTable = UI.getXmlTable()

  MAX_SCOREBOARD_LEN = 100
  populateScoreBoard(uiTable, 'playerScoreBoard', MAX_SCOREBOARD_LEN)
  populatePuzzleListContainer(uiTable)
  populatePieceListContainer(uiTable, gameState.pieceLabel)
  populateTemplateListContainer(uiTable, gameState.pieceLabel)

  UI.setXmlTable(uiTable)
end

function populateScoreBoard(uiTable, scoreBoardId, count)
  local scoreBoard = findElementById(uiTable, scoreBoardId)

  while #scoreBoard.children < count do
    local scoreId = scoreBoardId .. '_score' .. #scoreBoard.children + 1
    scoreBoard.children[#scoreBoard.children + 1] = {
      tag = 'Row',
      attributes = {
        id = scoreId,
        class = 'sbRecord',
        onClick = 'onClick_playerScoreBoardRow',
        active = false,
        tooltipPosition = 'Left',
      },
      children = {
        {
          tag = 'Cell',
          attributes = {
            class = 'sbName'
          },
          children = {
            {
              tag = 'Text',
              attributes = {
                id = scoreId .. '_name',
                class = 'sbRecord'
              }
            }
          }
        },
        {
          tag = 'Cell',
          attributes = {
            class = 'sbScore'
          },
          children = {
            {
              tag = 'Text',
              attributes = {
                id = scoreId .. '_score',
                class = 'sbRecord'
              }
            }
          }
        }
      }
    }

  end
end

function populateTemplateListContainer(uiTable, pieceLabel)
  local rows = 0
  local templateTable = {}
  for templateId, template in pairs(templateData) do
    if string.sub(templateId, 1, 2) == pieceLabel then
      local aspect = template.ratio
      local aspectTable = templateTable[aspect] or {}
      aspectTable[#aspectTable + 1] = {
        id = templateId,
        dimensions = template.dimensions,
        baseUrl = template.baseUrl
      }
      if #aspectTable > rows then rows = #aspectTable end
      templateTable[aspect] = aspectTable
    end
  end

  for aspect, aspectTable in pairs(templateTable) do
    table.sort(aspectTable, function(lhs, rhs) return lhs.dimensions.width * lhs.dimensions.height < rhs.dimensions.width * rhs.dimensions.height end)
  end

  local templateList = {}
  for row = 0, rows do
    local tableRow = {
      tag = 'Row',
      attributes = {},
      children = {}
    }
    if row == 0 then
      tableRow.attributes.class = 'templateHeaderRow'
    end

    for aspect, aspectTable in pairs(templateTable) do
      local template = aspectTable[row]

      local tableCell = {
        tag = 'Cell',
        children = {}
      }


      if row == 0 then
        local template = aspectTable[row + 1]
        tableCell.children[#tableCell.children + 1] = {
          tag = 'Text',
          attributes = {
            class = 'templateHeaderRow'
          },
          value = string.gsub(aspect,"x",":")
        }
      else
        if template ~= nil and template.baseUrl ~= nil then
          tableCell.children[#tableCell.children + 1] = {
            tag = 'ToggleButton',
            attributes = {
              id = template.id,
              class = 'templateSelection',
              onValueChanged = 'onValueChanged_templateSelection',
              tooltip = string.format(
                'Pieces: %d\nSize: %.2g MB',
                templateData[template.id].dimensions.width * templateData[template.id].dimensions.height,
                templateData[template.id].size
              ),
            },
            value = string.format('%d x %d', template.dimensions.width, template.dimensions.height)
          }
        end
      end

      tableRow.children[#tableRow.children + 1] = tableCell
    end

    templateList[#templateList + 1] = tableRow
  end

  local templateListContainer = findElementById(uiTable, 'templateListContainer')
  templateListContainer.children = templateList
end

function populatePuzzleListContainer(uiTable)
  local assets = {}

  local puzzleList = {}
  for puzzleId, puzzle in pairs(puzzleData) do
    puzzleList[#puzzleList + 1] = {
      tag = 'Button',
      attributes = {
        id = puzzleId,
        class = 'puzzlePicture',
        onClick = 'onClick_picture',
        icon = puzzleId,
        tooltip = string.format(
          'Resolution: %s\nSize: %.1f MB',
          puzzleData[puzzleId].resolution,
          puzzleData[puzzleId].size
        ),
      }
    }
    assets[#assets + 1] = {
      name = puzzleId,
      url = puzzleData[puzzleId].thumbnail
    }
  end

  local puzzleListContainer = findElementById(uiTable, 'puzzleListContainer')
  puzzleListContainer.attributes.width = string.format('%d', tonumber(UI.getAttribute('puzzleListContainer','height')) * #puzzleList)
  puzzleListContainer.children = puzzleList

  UI.setCustomAssets(assets)
end

function populatePieceListContainer(uiTable, pieceLabel)
  local assets = UI.getCustomAssets()

  local pieceList = {}
  for lbl, details in pairs(pieceTypeList) do
    local piecesId = lbl .. "PieceButton"
    pieceList[#pieceList + 1] = {
      tag = 'Button',
      attributes = {
        id = piecesId,
        color = pieceLabel == lbl and "rgba(1,1,1,1)" or "rgba(0,0,0,0)",
        class = 'piecePicture',
        onClick = 'onClick_pieceSelection',
        icon = piecesId,
        tooltip = details.description,
      }
    }
    assets[#assets + 1] = {
      name = piecesId,
      url = PUZZLE_URL .. 'res/pieces/' .. lbl .. '-sample.jpg'
    }
  end

  UI.setAttribute("templateTitle", "text", string.format("%s Piece Templates", pieceTypeList[pieceLabel].name))
  local pieceListContainer = findElementById(uiTable, 'pieceListContainer')
  pieceListContainer.attributes.height = string.format('%d', tonumber(UI.getAttribute('pieceListContainer','width')) * #pieceList)
  pieceListContainer.children = pieceList

  UI.setCustomAssets(assets)
end

function onClick_picture(player, button, id)
  UI.setAttribute('puzzleUrl', 'text', puzzleData[id].url)
  -- Search for a template id for the current piece set so we don't need to switch
  replacement_id = gameState.pieceLabel .. string.sub(puzzleData[id].templateId, 3, 99)
  if UI.getAttribute(replacement_id, 'id') == nil then
    onClick_pieceSelection(player, button, string.sub(puzzleData[id].templateId,1,2) .. "PieceButton",
          function() onValueChanged_templateSelection(player, true, puzzleData[id].templateId) end)
  else
    onValueChanged_templateSelection(player, true, replacement_id)
  end
end

function onClick_pieceSelection(player, button, id, callback_function)
  if gameState.pieceLabel != string.sub(id, 1, 2) then
    gameState.pieceLabel = string.sub(id, 1, 2)
    for lbl, details in pairs(pieceTypeList) do
      UI.setAttribute(lbl .. 'PieceButton', 'color', "rgba(0,0,0,0)")
    end
    Wait.frames(function()
          local uiTableOriginal = UI.getXmlTable()
          local uiTableEditable = UI.getXmlTable()
          findElementById(uiTableEditable, 'templateListContainer').children = {}
          findElementById(uiTableEditable, 'pieceListContainer').children = {}
          findElementById(uiTableEditable, 'puzzleListContainer').children = {}
          UI.setXmlTable(uiTableEditable)
          Wait.frames(function()
                populateTemplateListContainer(uiTableOriginal, gameState.pieceLabel)
                UI.setXmlTable(uiTableOriginal)
                Wait.frames(function()
                        for lbl, details in pairs(pieceTypeList) do
                          if id == lbl .. 'PieceButton' then
                            UI.setAttribute(lbl .. 'PieceButton', 'color', "rgba(1,1,1,1)")
                            UI.setAttribute('templateTitle', 'text', string.format("%s Piece Templates", details.name))
                          else
                            UI.setAttribute(lbl .. 'PieceButton', 'color', "rgba(0,0,0,0)")
                          end
                        end
                        if callback_function != nil then
                          Wait.frames(callback_function, 2)
                        end
                      end,
                      2)
              end,
              2)
        end,
        2)
  elseif callback_function != nil then
    callback_function()
  end
end

function onClick_ContinuePuzzleSelector()
  destroyPuzzle()

  local templateSelection = UI.getAttribute('templateSelection', 'selectedId')
  spawnPuzzle(templateSelection, UI.getAttribute('puzzleUrl', 'text'))

  UI.setAttribute('puzzleSelector', 'active', false)
end

function onClick_ContinueNewPictureUrl()
  changePictureUrl(UI.getAttribute('newPictureUrl', 'text'))
  UI.setAttribute('pictureUrlChanger', 'active', false)
end

function changePictureUrl(url)
  for _, obj in pairs(getObjects()) do
    if obj.getCustomObject().diffuse and gameState.pictureUrl and (obj.getCustomObject().diffuse == gameState.pictureUrl or getPieceId(obj)) then
      local properties = obj.getCustomObject()
      properties.diffuse = url
      obj.setCustomObject(properties)
      if next(obj.getAttachments()) then
        local droppedAttachments = obj.removeAttachments()
        for index, attachment in ipairs(droppedAttachments) do
          if attachment.getCustomObject().diffuse then
            local properties = attachment.getCustomObject()
            properties.diffuse = url
            attachment.setCustomObject(properties)
          end
          obj.addAttachment(attachment)
        end
       end
      obj.reload()
    end
  end
  gameState.pictureUrl = url
end

function onClick_playerScoreBoardRow(player, button, id)
  if player.host or player.admin and gameState.adminControl then
    update_scoreboard_delay = os.time() + 3
    local p = getPlayerState(UI.getAttribute(id .. '_name', 'text'))
    p.score = p.score + 1
    UI.setAttribute(id .. '_score', 'text', tostring(p.score))
  end
end

function destroyPuzzle()
  for index, object in ipairs(getObjects()) do
    if isBoard(object) or getPiece(object) then
      object.destruct()
    end
  end
  pieceCache = {}
end

function spawnPuzzle(templateId, picture)
  gameState.templateId = templateId
  gameState.pictureUrl = picture
  if templateData[templateId].pieces == nil then
    generatePieceData(templateData[templateId])
  end

  local board = spawnObject({
    type = 'Custom_Model',
    position = { x = 0, y = 1, z = 0 },
    rotation = { x = 0, y = 180, z = 0 }
  })
  board.setCustomObject({
    mesh = templateData[gameState.templateId].baseUrl .. 'board.obj',
    diffuse = picture,
    material = 3
  })



  local boardOffsetX = templateData[gameState.templateId].dimensions.width / 2 + 1.5
  local boardOffsetZ = templateData[gameState.templateId].dimensions.height / 2 + 1.5

  -- https://stackoverflow.com/questions/13894715/draw-equidistant-points-on-a-spiral
  local arc = 1.6
  local separation = 1.6
  local b = separation / (2 * math.pi)

  local r = arc
  local phi = r / b

  local spiralPositions = {}
  while #spiralPositions < #templateData[gameState.templateId].pieces do
    local position = Vector(
      r * math.cos(phi),
      1.25,
      r * math.sin(phi)
    )
    if math.abs(position.x) > boardOffsetX or math.abs(position.z) > boardOffsetZ then
      spiralPositions[#spiralPositions + 1] = position
    end
    phi = phi + arc / r
    r = b * phi
  end



  local shuffledPositions = {}
  for index, spiralPosition in ipairs(spiralPositions) do
    local pos = math.random(1, #shuffledPositions + 1)
    table.insert(shuffledPositions, pos, spiralPosition)
  end


  -- TODO save cache WIP
  pieceTextCache = ''

  gameState.guidCatalog = {}
  gameState.pieces = {}
  for name, _ in pairs(gameState.players) do
    gameState.players[name].duration = 0
  end
  for x = 1, #templateData[gameState.templateId].pieces do
    gameState.pieces[x] = {
      player_name = nil,
      joinedTo = nil,
      parentId = nil
    }

    local piece = spawnObject({
      type = 'Custom_Model',
      position = shuffledPositions[x],
      rotation = { x = 0, y = math.random(-180, 180), z = 0 },
      callback_function = function(o) gameState.guidCatalog[getPieceId(o)] = o.guid end
    })
    piece.setCustomObject({
      mesh = templateData[gameState.templateId].baseUrl .. 'piece.' .. x .. '.obj',
      diffuse = picture,
      material = 3,
      specular_intensity = 0
    })
    piece.sticky = false
  end
end

function _pairsBySorted(t, sort_func)
  sort_func = (type(sort_func) == "function") and sort_func or (|a,b|a[1]<b[1])
  local arr = {}
  for n, v in pairs(t) do table.insert(arr, {n,v}) end
  table.sort(arr, sort_func)
  local i = 0      -- iterator variable
  local iter = function ()   -- iterator function
        i = i + 1
        if arr[i] == nil then return nil
        else return arr[i][1], arr[i][2]
        end
      end
  return iter
end
function pairsBySortedKeys(t, sort_func)
  sort_func2 = (type(sort_func) == "function") and (|a,b|sort_func(a[1],b[1])) or (|a,b|a[1]<b[1])
  return _pairsBySorted(t, sort_func2)
end
function pairsBySortedValues(t, sort_func)
  sort_func2 = (type(sort_func) == "function") and (|a,b|sort_func(a[2],b[2])) or (|a,b|a[2]<b[2])
  return _pairsBySorted(t, sort_func2)
end

function showCredits()
  local start = os.time()

  local allProjectedPieceCoordinates = {}
  local allContributingPlayers = {}
  local biggestPieceGroup = {}
  local biggestPiece = nil
  for _, piece in ipairs(getAllPieces()) do
    local pieceGroup = { piece.id }
    for pieceId in iterJoinedTo(piece.id, false) do
      pieceGroup[#pieceGroup + 1] = pieceId
    end
    if #pieceGroup > #biggestPieceGroup then
      biggestPieceGroup = pieceGroup
      biggestPiece = piece
    end
  end
  if biggestPiece == nil then
    return
  end
  for _, pieceId in ipairs(biggestPieceGroup) do
    if gameState.pieces[pieceId].player_name then
      if allProjectedPieceCoordinates[gameState.pieces[pieceId].player_name] then
        table.insert(allProjectedPieceCoordinates[gameState.pieces[pieceId].player_name],projectPiecePosition(biggestPiece, pieceId))
      else
        allProjectedPieceCoordinates[gameState.pieces[pieceId].player_name] = {projectPiecePosition(biggestPiece, pieceId)}
      end
      allContributingPlayers[gameState.pieces[pieceId].player_name] = (allContributingPlayers[gameState.pieces[pieceId].player_name] or 0) + 1
    end
  end

  local it_contributions = pairsBySortedValues(allContributingPlayers,|a,b|a>b)
  local playerIndex = 0
  local panelIndex = 0

  local function showCreditsRoutine()
    UI.hide('creditsPanel1')
    UI.hide('creditsPanel2')

    local player_name, player_piece_count
    if UI.getAttribute('closeCredits', 'active') == 'True' then
      player_name, player_piece_count = it_contributions()
      playerIndex = playerIndex + 1
      if player_name == nil then
        -- recreate iterator for another pass and exit loop
        it_contributions = pairsBySortedValues(allContributingPlayers,|a,b|a>b)
        playerIndex = 0
      else
        panelIndex = panelIndex % 2 + 1
        UI.show('creditsPanel' .. tostring(panelIndex))
        local host_player = getHostPlayer()
        for _, piecePosition in ipairs(allProjectedPieceCoordinates[player_name]) do
          host_player.pingTable(piecePosition)
        end
        UI.setAttribute('creditsPlayerName' .. tostring(panelIndex), 'text', player_name)
        UI.setAttribute('creditsPlayerPosition' .. tostring(panelIndex), 'text', playerIndex)
        UI.setAttribute('creditsPlayerScore' .. tostring(panelIndex), 'text', player_piece_count)
        local hs = math.floor(gameState.players[player_name].duration / 60 / 60)
        local ms = math.floor(gameState.players[player_name].duration/60) % 60
        if hs > 0 then
          UI.setAttribute('creditsPlayerDuration' .. tostring(panelIndex), 'text', string.format('%dh%02dm', hs, ms))
        else
          UI.setAttribute('creditsPlayerDuration' .. tostring(panelIndex), 'text', string.format('%dm',ms))
        end
      end

      Wait.time(showCreditsRoutine, 5)
    end
  end

  if not showing_credits then
    if next(allContributingPlayers) ~= nil then
      UI.setAttribute('closeCredits', 'active', true)
      showing_credits = true
      Wait.frames(showCreditsRoutine, 1)
    end

  end

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'showCredits elapsed: %.2f, #allProjectedPieceCoordinates: %d',
      os.time() - start,
      #allProjectedPieceCoordinates
    ))
  end
end


function onClick_ShowCredits()
  if UI.getAttribute('closeCredits', 'active') == 'True' then return end
  showCredits()
end


function onClick_CloseCredits()
  showing_credits = false
  UI.setAttribute('closeCredits', 'active', false)
end


function onValueChanged_puzzleEnabled(player, value, id)
  gameState.puzzleEnabled = value == "True"
  setPuzzleEnabled(gameState.puzzleEnabled)
end

function onValueChanged_adminControl(player, value, id)
  gameState.adminControl = value == "True"
  setAdminControl(gameState.adminControl)
end

function onClick_debug_level()
  gameState.debug_level = (gameState.debug_level + 1) % 5
  if gameState.debug_level == 0 then
    UI.setAttribute('debug_level', 'text', "Debugging Off")
  else
    UI.setAttribute('debug_level', 'text', "Debug Level "..tostring(gameState.debug_level))
  end
end

function getAllPieces()
  local start = os.time()

  local allObjects = getObjects()
  local allPieces = {}
  for index, object in ipairs(allObjects) do
    local piece = getPiece(object)

    if piece ~= nil then
      allPieces[#allPieces + 1] = piece
    end
  end

  if gameState.debug_level >= 3 then
    debugPrint(string.format(
      'getAllPieces #allPieces: %s, #allObjects: %s, elapsed: %.2f',
      tostring(#allPieces),
      tostring(#allObjects),
      os.time() - start
    ))
  end

  return allPieces
end

function getTheBigOne()
  -- finds whether there is a really big piece that other pieces are being joined to
  local the_big_one = nil
  local first_max = 0
  local second_max = 0
  for _, p in pairs(getAllPieces()) do
    local group_size = #p.object.getAttachments() + 1
    if group_size >= first_max then
      the_big_one = p
      second_max = first_max
      first_max = group_size
    end
  end
  if first_max > 3 and (first_max > 3 * second_max or first_max > second_max + 15) then
    return the_big_one
  end

  return nil
end


function calcTime(duration)
  local seconds = duration

  local hours = math.floor(seconds / 3600)
  seconds = seconds % 3600

  local minutes = math.floor(seconds / 60)
  seconds = seconds % 60

  return { H = hours, M = minutes, S = seconds } --%H:%M:%S
end



function onWaitMain()
  if not gameState.puzzleEnabled then return end

  local start = os.time()

  gameState.duration = gameState.duration + 1

  for index, player in ipairs(Player.getPlayers()) do
    local playerState = getPlayerState(player.steam_name)
    playerState.duration = playerState.duration + 1

    local teamState = getTeamState(player.team)
    teamState.duration = teamState.duration + 1

    checkPlayerSelection(player)

  end

  updateScoreBoards()

  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'onWaitMain elapsed: %.2f',
      os.time() - start
    ))
  end
end

function getPlayerState(player_name)
  if gameState.players[player_name] == nil then
    gameState.players[player_name] = {
      duration = 0,
      score = 0
    }
  end
  return gameState.players[player_name]
end

function getTeamState(team_name)
  if gameState.teams[team_name] == nil then
    gameState.teams[team_name] = {
      duration = 0,
      score = 0
    }
  end
  return gameState.teams[team_name]
end

function onClick_teamScoreBoardTitle(player, button, id)
  if not player.admin then return end
  show = showTeamScoreBoard ~= true  -- initially set to true
  updateTeamScoreBoard(show)
  local offsetX, offsetY = UI.getAttribute('scoreBoards', 'offsetXY'):gmatch("(.*) (.*)")()
  local height = tonumber(UI.getAttribute('scoreBoards', 'height'))
  local newheight = height + 30*3*(show and 1 or -1) --
  offsetY = tostring(tonumber(offsetY) - math.floor(math.abs((newheight - height) / 2)) * (newheight-height > 0 and 1 or -1))
  UI.setAttribute('scoreBoards', 'height', tostring(newheight))
  UI.setAttribute('scoreBoards', 'offsetXY', offsetX.." "..offsetY)
  UI.setAttribute('teamScoreBoardRow', 'active', tostring(show))
end

function onClick_playerScoreBoardTitle(player, button, id)
  if not player.admin then return end
  local show = UI.getAttribute('playerScoreBoardRow', 'active') ~= 'true'
  local offsetX, offsetY = UI.getAttribute('scoreBoards', 'offsetXY'):gmatch("(.*) (.*)")()
  local height = tonumber(UI.getAttribute('scoreBoards', 'height'))
  local newheight = height + 324 * (show and 1 or -1)
  offsetY = tostring(tonumber(offsetY) - math.floor(math.abs((newheight - height) / 2)) * (newheight-height > 0 and 1 or -1))
  UI.setAttribute('scoreBoards', 'height', tostring(newheight))
  UI.setAttribute('scoreBoards', 'offsetXY', offsetX.." "..offsetY)
  UI.setAttribute('playerScoreBoardRow', 'active', tostring(show))
end

function onClick_puzzleControls(player, button, id)
  local show = UI.getAttribute('puzzleControlsRow', 'active') ~= 'true'
  local offsetX, offsetY = UI.getAttribute('puzzleControls', 'offsetXY'):gmatch("(.*) (.*)")()
  local height = tonumber(UI.getAttribute('puzzleControls', 'height'))
  local newheight = height + 202 * (show and 1 or -1)
  offsetY = tostring(tonumber(offsetY) - math.floor(math.abs((newheight - height) / 2)) * (newheight-height > 0 and 1 or -1))
  UI.setAttribute('puzzleControls', 'height', tostring(newheight))
  UI.setAttribute('puzzleControls', 'offsetXY', offsetX.." "..offsetY)
  UI.setAttribute('puzzleControlsRow', 'active', tostring(show))
end

function printInvalidPieces()
  -- Make a lookup table of all valid piece GUIDs
  local allValidPieceGUIDs = {}
  for _, guid in pairs(gameState.guidCatalog) do
    allValidPieceGUIDs[guid] = true
  end

  local allPieceGUIDs = {}
  for _, piece in pairs(getAllPieces()) do
    local allAttachments = piece.object.getAttachments()
    allPieceGUIDs[piece.object.guid] = true
    for _, attachment in pairs(allAttachments) do
      allPieceGUIDs[attachment.guid] = true
    end
  end

  s = ""
  for guid,_ in pairs(allPieceGUIDs) do
    if not allValidPieceGUIDs[guid] then
      s = s..(s=="" and "Invalid guids:" or ",")..guid
    end
  end
  print(s)
end

function onClick_RecoverDeletedPieces(player, button, id)
  if gameState.templateId == nil or gameState.guidCatalog == nil or next(gameState.guidCatalog) == nil then return end

  -- Make a reverse lookup table of all valid piece GUIDs
  local allValidPieceGUIDs = {}
  for pieceId, guid in pairs(gameState.guidCatalog) do
    allValidPieceGUIDs[guid] = pieceId
  end

  local the_big_one = getTheBigOne()

  -- Track some pieces to show the player where they are
  local objectsToShow = {}
  local show_level = 0  -- first show any piece, then locked piece, then deleted piece

  -- Find all piece GUIDs on the table
  -- Also delete any invalid GUID pieces
  local allPieceGUIDs = {}
  for _, piece in pairs(getAllPieces()) do
    if piece != the_big_one and piece.object != nil then
      if show_level <= 0 then
        -- 1 piece with nothing wrong it will be shown to the player later
        table.insert(objectsToShow, piece.object)
      end
      if not piece.object.interactable or piece.object.locked then

        if show_level <= 1 then
          -- 1 piece that was locked will be shown to the player later
          if show_level < 1 then
            show_level = 1
            objectsToShow = {}
          end
          table.insert(objectsToShow, piece.object)
        end

        piece.object.interactable = true
        piece.object.locked = false
      end
    end
    local allAttachments = piece.object.getAttachments()
    if allValidPieceGUIDs[piece.object.guid] == nil and #allAttachments < 10 then
      piece.object.destruct()
    else
      allPieceGUIDs[piece.object.guid] = true
      if allValidPieceGUIDs[piece.object.guid] == nil then
        -- a large piece does not have a valid guid, so make it valid
        pieceId = getPieceId(piece.object)
        allValidPieceGUIDs[gameState.guidCatalog[pieceId]] = nil
        gameState.guidCatalog[pieceId] = piece.object.guid
        allValidPieceGUIDs[gameState.guidCatalog[pieceId]] = pieceId
      end

      -- delete invalid attachments in reverse order to 1-shot it without messing up
      for i = #allAttachments, 1, -1 do
        attachment = allAttachments[i]
        allPieceGUIDs[attachment.guid] = true
        if not allValidPieceGUIDs[attachment.guid] then
          piece.object.destroyAttachment(attachment.index)
        end
      end
    end
  end

  -- Replace all missing or invalid pieces
  for pieceId = 1, #gameState.pieces do
    if gameState.guidCatalog[pieceId] and allPieceGUIDs[gameState.guidCatalog[pieceId]] == nil then
      -- The piece does not exist so replace it
      local object = spawnObject({
        type = 'Custom_Model',
        position = {x=0,y=5,z=0},
        rotation = { x = 0, y = 0, z = 0 },
        callback_function = function(o) gameState.guidCatalog[getPieceId(o)] = o.guid end
      })
      object.setCustomObject({
        mesh = templateData[gameState.templateId].baseUrl .. 'piece.' .. pieceId .. '.obj',
        diffuse = gameState.pictureUrl,
        material = 3,
        specular_intensity = 0
      })
      object.sticky = false

      if show_level <= 2 then
        -- 1 piece that was deleted will be shown to the player later
        if show_level < 2 then
          show_level = 2
          objectsToShow = {}
        end
        table.insert(objectsToShow, object)
      end
    end
  end

   -- Show a random problematic piece to the player
  if #objectsToShow > 0 then
    local o = objectsToShow[math.random(#objectsToShow)]
    player.lookAt({position = {o.getPosition().x, 1, o.getPosition().z}, pitch = 80, yaw = 0, distance = 15})
    o.highlightOn({1,1,0}, 3)
  end

  -- Rebuild parentId and joinedTo
  for _, piece in pairs(getAllPieces()) do
    local allAttachments = piece.object.getAttachments()
    if next(allAttachments) then
      -- Loop through all attachments and assign correct values
      gameState.pieces[piece.id].parentId = piece.id
      local lastPieceId = piece.id
      for _, attachment in pairs(allAttachments) do
        local pieceId = allValidPieceGUIDs[attachment.guid]
        if pieceId ~= nil then
          gameState.pieces[lastPieceId].joinedTo = pieceId
          gameState.pieces[pieceId].parentId = piece.id
          lastPieceId = pieceId
        else
          -- We should never reach here, but it is not entirely out of the question
          print("Rebuilding parentIds and joinedTos failed somewhere.")
        end
      end
      gameState.pieces[lastPieceId].joinedTo = piece.id
    else
      -- Piece has no attachments
      gameState.pieces[piece.id].joinedTo = nil
      gameState.pieces[piece.id].parentId = nil
      gameState.pieces[piece.id].player_name = nil
    end
  end
  onCheckSolutionRequest()
end

function onClick_ChangePictureUrl(player, button, id)
  if gameState.templateId == nil or gameState.pictureUrl == nil then return end
  UI.setAttribute('newPictureUrl', 'text', gameState.pictureUrl)
  UI.setAttribute('pictureUrlChanger', 'active', true)
end

function updateScoreBoards()
  local start = os.time()

  updateTeamScoreBoard()
  updatePlayerScoreBoard()

  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'updateScoreBoards elapsed: %.2f seconds',
      os.time() - start
    ))
  end
end

function getTeamScoreData()
  local teamScoreBoard = {}
  for teamName, teamData in pairs(gameState.teams) do
    teamScoreBoard[#teamScoreBoard + 1] = {
      name = teamName,
      score = teamData.score,
      duration = teamData.duration
    }
  end
  table.sort(teamScoreBoard, function(lhs, rhs) return lhs.score > rhs.score end)
  return teamScoreBoard
end

function getPlayerScoreData()

  inRoom = {}
  for _, p in pairs(Player.getPlayers()) do
    inRoom[p.steam_name] = true
  end

  local playerScoreBoard = {}
  for playerName, playerData in pairs(gameState.players) do
    if playerData.score > 0 or inRoom[playerName] then
      playerScoreBoard[#playerScoreBoard + 1] = {
        name = playerName,
        score = playerData.score,
        duration = playerData.duration
      }
    end
  end

  table.sort(playerScoreBoard, function(lhs, rhs)
          if (lhs.duration > 300 and lhs.score > 0 or inRoom[lhs.name] == true) ~= (rhs.duration > 300 and rhs.score > 0 or inRoom[rhs.name] == true) then
            return lhs.duration > 300 and lhs.score > 0 or inRoom[lhs.name] == true
          end
          return lhs.score > rhs.score
        end)
  return playerScoreBoard
end

currentPlayerScoreBoardData = {}
function updatePlayerScoreBoard()
  local start = os.time()
  
  if update_scoreboard_delay != nil and os.time() < update_scoreboard_delay then
    if gameState.debug_level >= 2 then
      debugPrint(string.format(
        'updatePlayerScoreBoard skipping scoreboard update until %d',
        update_scoreboard_delay,
        os.time() - start
      ))
    end
    return
  end
  update_scoreboard_delay = nil

  local colorTable = {}
  for index, player in ipairs(Player.getPlayers()) do
    colorTable[player.steam_name] = player.color
  end

  local scoreBoardData = getPlayerScoreData()

  local UIchanges = 0
  for index, scoreData in ipairs(scoreBoardData) do
    if index > MAX_SCOREBOARD_LEN then
      break
    end

    local scoreId = 'playerScoreBoard_score' .. index
    local name = scoreData.name
    local score = scoreData.score
    local color = '#808080'

    local elapsed = calcTime(scoreData.duration)
    local tooltip = string.format(
      'Time in Game: %02d:%02d:%02d\nPieces per Minute: %.1f',
      elapsed.H, elapsed.M, elapsed.S,
      scoreData.score / (scoreData.duration / 60)
    )

    local playerColor = colorTable[name]
    if playerColor ~= nil then
      color = '#' .. Color.fromString(playerColor):toHex()
    end

    local entry = currentPlayerScoreBoardData[index] or {}
    if entry.score ~= score then
      UI.setAttribute(scoreId .. '_score', 'text', score)
      entry.score = score
      UIchanges = UIchanges + 1
    end
    if entry.name ~= name then
      UI.setAttribute(scoreId .. '_name', 'text', name)
      entry.name = name
      UIchanges = UIchanges + 1
    end
    if entry.color ~= color then
      UI.setAttribute(scoreId, 'color', color)
      entry.color = color
      UIchanges = UIchanges + 1
    end
    if entry.tooltip ~= tooltip and Time.time - (entry.tooltip_tm or 0) > math.random(9,11) then
      UI.setAttribute(scoreId, 'tooltip', tooltip)
      entry.tooltip = tooltip
      entry.tooltip_tm = Time.time
      UIchanges = UIchanges + 1
    end
    if not currentPlayerScoreBoardData[index] then
      UI.setAttribute(scoreId, 'active', true)
      UIchanges = UIchanges + 1
    end
    currentPlayerScoreBoardData[index] = entry
  end

  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'updatePlayerScoreBoard UIchanges: %d elapsed: %.2f seconds',
      UIchanges,
      os.time() - start
    ))
  end
end

currentTeamScoreBoardData = {}
function updateTeamScoreBoard(show)
  local start = os.time()

  if show == nil then
    show = showTeamScoreBoard == true -- Default is false
  end

  local scoreBoardData = getTeamScoreData()
  for index = 1, 6 do
    scoreData = scoreBoardData[index]
    local scoreId = 'teamScoreBoard_score' .. index
    if index == 1 or scoreData and scoreData.score > 0 then
      local name = scoreData.name
      local score = scoreData.score

      local elapsed = calcTime(scoreData.duration)
      local tooltip = string.format(
        'Time in Game: %02d:%02d:%02d\nPieces per Minute: %.1f',
        elapsed.H, elapsed.M, elapsed.S,
        scoreData.score / (scoreData.duration / 60)
      )

      UI.setAttribute(scoreId .. '_score', 'text', score)
      UI.setAttribute(scoreId .. '_name', 'text', name)
      UI.setAttribute(scoreId, 'active', tostring(show))
      UI.setAttribute(scoreId, 'tooltip', tooltip)
    else
      UI.setAttribute(scoreId, 'active', tostring(false))
      UI.setAttribute(scoreId .. '_score', 'text', nil)
      UI.setAttribute(scoreId .. '_name', 'text', nil)
      UI.setAttribute(scoreId, 'tooltip', nil)
    end
  end
  showTeamScoreBoard = show

  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'updateTeamScoreBoard elapsed: %.2f seconds',
      os.time() - start
    ))
  end
end

function getPieceId(object)
  if object == nil then return end
  if gameState.templateId == nil then return end
  if type(object) ~= "userdata" or object.tag == nil or object.tag ~= 'Generic' then return end

  local customObject = object.getCustomObject()
  if customObject then
    local mesh = customObject.mesh
    if mesh then
      local pieceMatch = string.gsub(templateData[gameState.templateId].baseUrl, '-', '%%-') .. 'piece%.(%d+)%.obj'
      local piece = string.match(mesh, pieceMatch)
      if piece then
        return piece + 0 -- make numeric
      end
    end
  end
end



function isBoard(object)
  if object == nil then return end
  if gameState.templateId == nil then return end
  if object.tag == nil or object.tag ~= 'Generic' then return end

  local customObject = object.getCustomObject()
  if customObject then
    local mesh = customObject.mesh
    if mesh then
      local boardMatch = string.gsub(templateData[gameState.templateId].baseUrl, '-', '%%-') .. 'board.obj'
      if string.find(mesh, boardMatch) then
        return true
      end
    end
  end
end



-- Converts a TTS object type into a Piece type
-- caches all object lookups but only returns valid pieces
pieceCache = {}
function getPiece(objectOrId)
  local start = os.time()

  local piece = pieceCache[objectOrId]
  if piece == nil then
    if type(objectOrId) == "number" then
      local pieceId = objectOrId
      for i, o in pairs(getObjects()) do
        local checkId = getPieceId(o)
        if checkId != nil and pieceCache[checkId] == nil then
          local piece_to_add = {
            id = checkId,
            object = o,
            solutionPosition = nil
          }
          piece_to_add.solutionPosition = Vector(templateData[gameState.templateId].pieces[piece_to_add.id].solutionPosition)
          piece_to_add.solutionRotation = Vector(templateData[gameState.templateId].pieces[piece_to_add.id].solutionRotation) + Vector(0, 180, 0)
          pieceCache[piece_to_add.id] = piece_to_add
          pieceCache[o] = piece_to_add
          if checkId == pieceId then
            piece = piece_to_add
          end
        end
      end
    else
      local checkId = getPieceId(objectOrId)
      
      -- if checkId is nil then this object is not a piece
      if checkId != nil then
        piece = {
          id = checkId,
          object = objectOrId,
          solutionPosition = nil
        }
        if piece.id ~= nil then
          piece.solutionPosition = Vector(templateData[gameState.templateId].pieces[piece.id].solutionPosition)
          piece.solutionRotation = Vector(templateData[gameState.templateId].pieces[piece.id].solutionRotation) + Vector(0, 180, 0)
          pieceCache[piece.id] = piece
        end
        pieceCache[objectOrId] = piece
      end
    end
  end
  if piece == nil or piece.id == nil then return end

  if gameState.debug_level >= 4 then
    debugPrint(string.format(
      'getPiece object: %s elapsed: %.2f seconds',
      tostring(objectOrId),
      os.time() - start
    ))
  end
  return piece
end

function projectPiecePosition(targetPiece, pieceId)
  local start = os.time()

  local offsetSolutionPosition = Vector(templateData[gameState.templateId].pieces[pieceId].solutionPosition) - targetPiece.solutionPosition

  local targetRotationDelta = targetPiece.object.getRotation() - targetPiece.solutionRotation

  local rotatedOffsetSolutionPosition = rotateY(offsetSolutionPosition, targetRotationDelta.y)

  local targetPosition = targetPiece.object.getPosition()

  local projectedObjectPosition = targetPosition + rotatedOffsetSolutionPosition

  if gameState.debug_level >= 99 then
    debugPrint(string.format(
      'projectPiecePosition droppedPiece.id: %s, targetPiece.id: %s, \n\tdroppedPiece.solutionPosition: %s, targetPiece.solutionPosition: %s, offsetSolutionPosition: %s, \n\ttargetRotation: %s, rotationYOffset: %s, rotatedOffsetSolutionPosition: %s, \n\ttargetPosition: %s, projectedObjectPosition: %s, elapsed: %.2f seconds',
      pieceId,
      targetPiece.id,
      dumpTTSVector(pieceData[pieceId].solutionPosition),
      dumpTTSVector(targetPiece.solutionPosition),
      dumpTTSVector(offsetSolutionPosition),
      dumpTTSVector(targetRotation),
      rotationYOffset,
      dumpTTSVector(rotatedOffsetSolutionPosition),
      dumpTTSVector(targetPosition),
      dumpTTSVector(projectedObjectPosition),
      os.time() - start
    ))
  end

  return projectedObjectPosition
end






function snapPieces(droppedPiece, targetPiece)
  local start = os.time()

  local projectedObjectPosition = projectPiecePosition(targetPiece, droppedPiece.id)

  droppedPiece.object.setPositionSmooth({
    x = projectedObjectPosition.x,
    y = droppedPiece.object.getPosition().y,
    z = projectedObjectPosition.z
  })

  local targetRotationDelta = targetPiece.object.getRotation() - targetPiece.solutionRotation
  local snapRotation = targetRotationDelta + droppedPiece.solutionRotation

  droppedPiece.object.setRotationSmooth({ x = 0, y = snapRotation.y, z = 0 })

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'snapPieces droppedPiece.id: %s, targetPiece.id: %s, elapsed: %.2f seconds',
      droppedPiece.id,
      targetPiece.id,
      os.time() - start
    ))
  end
end






function attachPieces(droppedPiece, targetPiece)
  local start = os.time()

  local projectedObjectPosition = projectPiecePosition(targetPiece, droppedPiece.id)

  droppedPiece.object.setPosition(projectedObjectPosition)

  local targetRotation = targetPiece.object.getRotation()
  local targetRotationDelta = targetRotation - targetPiece.solutionRotation
  local snapRotation = targetRotationDelta + droppedPiece.solutionRotation

  droppedPiece.object.setRotation({ x = 0, y = snapRotation.y, z = 0 })
  targetPiece.object.setRotation({ x = 0, y = targetRotation.y, z = 0 })

  local droppedAttachments = droppedPiece.object.removeAttachments()
  for index, attachment in ipairs(droppedAttachments) do
    targetPiece.object.addAttachment(attachment)
  end

  targetPiece.object.addAttachment(droppedPiece.object)

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'attachPieces droppedPiece.id: %s, targetPiece.id: %s, elapsed: %.2f seconds',
      droppedPiece.id,
      targetPiece.id,
      os.time() - start
    ))
  end
end






function arePiecesAligned(droppedPiece, targetPiece)
  local start = os.time()

  local objectRotation = droppedPiece.object.getRotation()
  local targetRotation = targetPiece.object.getRotation()

  local droppedRotationDelta = droppedPiece.object.getRotation() - droppedPiece.solutionRotation
  local targetRotationDelta = targetPiece.object.getRotation() - targetPiece.solutionRotation

  local rotationDelta = normalizeRotation(droppedRotationDelta - targetRotationDelta)

  local objectPosition = droppedPiece.object.getPosition()
  local projectedPosition = projectPiecePosition(targetPiece, droppedPiece.id)

  local positionDelta = objectPosition - projectedPosition

  local result = false

  if math.abs(rotationDelta.y) < 35 and
    math.abs(positionDelta.x) < 0.75 and
    math.abs(positionDelta.z) < 0.75 then

    result = true
  end

  if gameState.debug_level >= 3 then
    debugPrint(string.format(
      'arePiecesAligned droppedPiece.id: %s, targetPiece.id: %s, result: %s, elapsed: %.2f, rotationDelta: %s, positionDelta: %s',
      droppedPiece.id,
      targetPiece.id,
      tostring(result),
      os.time() - start,
      dumpTTSVector(rotationDelta),
      dumpTTSVector(positionDelta)
    ))
  end

  return result
end







activeMerges = {}
function onPieceDropped(player_color, droppedPiece)
  local start = os.time()

  activeMerges[droppedPiece.id] = activeMerges[droppedPiece.id] or 0

  if gameState.debug_level >= 3 then
    debugPrint(string.format(
      'onPieceDropped player_color: %s, droppedPiece.id: %d, activeMerges: %d',
      player_color,
      droppedPiece.id,
      activeMerges[droppedPiece.id]
    ))
  end

  if activeMerges[droppedPiece.id] > 0 then return end

  local droppedPieceGroup = {}
  for pieceId in iterJoinedTo(droppedPiece.id) do
    droppedPieceGroup[pieceId] = true
  end

  local candidateMatches = {}
  for pieceId, _ in pairs(droppedPieceGroup) do
    for _, targetId in ipairs(templateData[gameState.templateId].pieces[pieceId].neighbors) do
      targetId = gameState.pieces[targetId].parentId or targetId

      if droppedPieceGroup[targetId] == nil then
        candidateMatches[targetId] = true
      end
    end
  end

  local player = Player[player_color]
  for targetId, _ in pairs(candidateMatches) do
    local targetPiece = getPiece(targetId)

      if targetPiece ~= nil and targetPiece.object ~= nil and arePiecesAligned(droppedPiece, targetPiece) then
        joinPieces(player, droppedPiece, targetPiece)
        break
      end
  end

  if gameState.debug_level >= 3 then
    debugPrint(string.format(
      'onPieceDropped player_color: %s, droppedPiece.id: %s, elapsed: %.2f, droppedPieceGroup: [%s], candidateMatches: [%s]',
      player_color,
      droppedPiece.id,
      os.time() - start,
      printTable(droppedPieceGroup,true),
      printTable(candidateMatches,true)
    ))
  end
end


function joinPieces(player, droppedPiece, targetPiece, animated)
  animated = animated ~= false -- Default is true

  activeMerges[targetPiece.id] = (activeMerges[targetPiece.id] or 0) + 1
  activeMerges[droppedPiece.id] = (activeMerges[droppedPiece.id] or 0) + 1

  droppedPiece.object.interactable = false

  droppedPiece.object.removeFromPlayerSelection(player.color)

  lastPlayerToConnect = {steam_name=player.steam_name, team=player.team}
  local playerState = getPlayerState(player.steam_name)
  playerState.score = playerState.score + 1

  local teamState = getTeamState(player.team)
  teamState.score = teamState.score + 1

  local droppedPieceState = gameState.pieces[droppedPiece.id]
  local targetPieceState = gameState.pieces[targetPiece.id]
  droppedPieceState.player_name = player.steam_name
  targetPieceState.player_name = targetPieceState.player_name or player.steam_name

  targetJoinedTo = targetPieceState.joinedTo
  targetPieceState.joinedTo = droppedPieceState.joinedTo or droppedPiece.id
  droppedPieceState.joinedTo = targetJoinedTo or targetPiece.id

  for pieceId in iterJoinedTo(targetPiece.id) do
    gameState.pieces[pieceId].parentId = targetPiece.id
  end

  -- TODO save cache WIP
  pieceTextCache = ''

  if animated then
    snapPieces(droppedPiece, targetPiece)
  end

  local toRunFunc = function()
    droppedPiece.object.interactable = true

    attachPieces(droppedPiece, targetPiece)

    activeMerges[targetPiece.id] = activeMerges[targetPiece.id] - 1
    activeMerges[droppedPiece.id] = activeMerges[droppedPiece.id] - 1

    if animated then
      Wait.frames(onCheckSolutionRequest, 1)
    end
  end

  local conditionFunc = function()
    return not droppedPiece.object.isSmoothMoving() and droppedPiece.object.resting
  end

  local timeout = 2 -- seconds

  local timeoutFunc = function()
    if gameState.debug_level >= 3 then
      debugPrint(string.format(
        'timeoutFunc droppedPiece.id: %d, isSmoothMoving: %s, resting: %s, held_by_color: %s',
        droppedPiece.id,
        tostring(droppedPiece.object.isSmoothMoving()),
        tostring(droppedPiece.object.resting),
        tostring(droppedPiece.object.held_by_color)
      ))
    end
    toRunFunc()
  end
  if animated then
    Wait.condition(toRunFunc, conditionFunc, timeout, timeoutFunc)
  else
    toRunFunc()
  end
end

function isAdjacentPiece(piece1, piece2)
  if piece1 and piece1.solutionPosition and piece2 and piece2.solutionPosition then
    return math.abs(piece1.solutionPosition.x - piece2.solutionPosition.x) < 0.5 or math.abs(piece1.solutionPosition.z - piece2.solutionPosition.z) < 0.5
  end
  return false
end

function onChat(msg,player)
  if msg:match("^!puzzle") then
    if msg:match("edges") then
      for pieceId, info in pairs(templateData[gameState.templateId].pieces) do
        if #info.neighbors <= 5 and gameState.pieces[pieceId].joinedTo == nil then
          local piece = getPiece(pieceId)
          if piece and piece.object ~= nil and piece.object.locked == false then
            piece.object.setPosition(player.getPointerPosition())
          end
        end
      end
    elseif msg:match("join") or msg:match("solve") then
      pcall(function()
        local pieces
        if msg:match("solve") then
          pieces = getAllPieces()
        else
          pieces = {}
          for _,v in pairs(player.getSelectedObjects()) do
            table.insert(pieces, getPiece(v))
          end
        end
        if next(pieces) then
          local mainpiece = nil
          local joinPieceQueue = {}
          for i = 1, #pieces do
            if mainpiece == nil then
              mainpiece = pieces[i]
              mainpiece.object.locked = true
            else
              --joinPieces(player,pieces[i],mainpiece,false)
              table.insert(joinPieceQueue,{player,pieces[i],mainpiece,false})
            end
          end
          local function doNextJoinPieces()
            for _ = 1, 100 do
              args = table.remove(joinPieceQueue)
              if args then
                joinPieces(table.unpack(args))
              end
            end
            if next(joinPieceQueue) then
              Wait.frames(doNextJoinPieces,20)
            else
              onCheckSolutionRequest()
            end
          end
          doNextJoinPieces()
        end
      end)
    end
    return false
  elseif string.len(msg) == 1 then
    return false
  end
end

function onCheckSolutionRequest()
  -- Prevent function from running many times in a short period of time
  if checkSolution_waitId then
    Wait.stop(checkSolution_waitId)
    checkSolution_waitId = nil
  end
  checkSolution_waitId = Wait.time(function() onCheckSolution() end, 0.5)
end

function onCheckSolution()
  local start = os.time()

  local parentIdCounts = {}
  for pieceId, state in pairs(gameState.pieces) do
    if state.parentId ~= nil then
      parentIdCounts[state.parentId] = (parentIdCounts[state.parentId] or 0) + 1
    end
  end
  for pieceId, numattached in pairs(parentIdCounts) do
    if numattached == #templateData[gameState.templateId].pieces then
      --printToAll('Victory!!!')
      if lastPlayerToConnect then
        local playerState = getPlayerState(lastPlayerToConnect.steam_name)
        playerState.score = playerState.score + 1
        local teamState = getTeamState(lastPlayerToConnect.team)
        teamState.score = teamState.score + 1
      end
      showCredits()
      break
    end
  end

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'onCheckSolution elapsed: %.2f',
      os.time() - start
    ))
  end
end



function table_contains(tab, val)
  for index, value in ipairs(tab) do
    if value == val then
      return true
    end
  end

  return false
end



function dumpTTSVector(vector)
  return string.format(
    '{ x: %.3f, y: %.3f, z: %.3f }',
    vector.x,
    vector.y,
    vector.z
  )
end



function debugPrint(message)
  if gameState.debug_level ~= 0 then
    local time = os.time()
    local date = os.date('*t', time)
    local milliseconds = time % 1
    log(string.format(
      '[%d-%02d-%02d-%02d:%02d:%d%f][%d] %s',
      date.year,
      date.month,
      date.day,
      date.hour,
      date.min,
      math.floor(date.sec / 10),
      (date.sec + milliseconds) % 10,
      Time.frame_count,
      message
    ))
  end
end





function normalizeRotation(rotVector)
  local norVector = rotVector:copy()

  while norVector.x > 180 do
    norVector.x = norVector.x - 360
  end
  while norVector.x < -180 do
    norVector.x = norVector.x + 360
  end
  while norVector.y > 180 do
    norVector.y = norVector.y - 360
  end
  while norVector.y < -180 do
    norVector.y = norVector.y + 360
  end
  while norVector.z > 180 do
    norVector.z = norVector.z - 360
  end
  while norVector.z < -180 do
    norVector.z = norVector.z + 360
  end

  return norVector
end





-- https://stackoverflow.com/a/14609567/1973231
-- Rotation in 3D around the Y-axis
-- | cos $d    0   sin $d| |x|   | x cos $d + z sin $d|   |x'|
-- |   0       1        0| |y| = |          y         | = |y'|
-- |-sin $d    0   cos $d| |z|   |-x sin $d + z cos $d|   |z'|
function rotateY(vector, degrees)
  local newVector = vector:copy()

  local radians = math.rad(degrees)

  newVector.x = vector.x * math.cos(radians) + vector.z * math.sin(radians)
  newVector.y = vector.y
  newVector.z = -1 * vector.x * math.sin(radians) + vector.z * math.cos(radians)

  return Vector(newVector)
end

-- A poor but adequate random sequence generator
RNG = {
  new = function(class, seed)
    local self = setmetatable({}, class)
    local m, a = 33554393, 25612572 -- (m-1) * a must be < 10^15
    local state = (seed + 1) % m
    self.randbetween = function(v1, v2)
        state = (a * state) % m
        return math.floor(state / m * (v2 - v1 + 1)) + v1
      end
    self.rand = function()
        state = (a * state) % m
        return state / m
      end
    return self
  end
}

function generatePieceData(details)

  local start = os.time()

  local seed = details.seed
  local dims = details.dimensions
  local rng = RNG:new(seed)
  local pieceData = {}
  for ih =  1, dims.height do
    for iw = 1, dims.width do
      local neighbors = {}
      for dy = math.max(-1, 1-ih), math.min(1, dims.height - ih) do
        for dx = math.max(-1, 1-iw), math.min(1, dims.width - iw) do
          if dx != 0 or dy != 0 then
            table.insert(neighbors, (ih + dy - 1) * dims.width + iw + dx)
          end
        end
      end
      table.insert(pieceData,{neighbors = neighbors, solutionPosition = {x=iw, y=1, z=-ih}, solutionRotation = {x=0, y=90 * rng.randbetween(0, 3), z=0}})
    end
  end
  details.pieces = pieceData

  if gameState.debug_level >= 2 then
    debugPrint(string.format(
      'generatePieceData #pieceData: %d, elapsed: %.2f',
      #pieceData,
      os.time() - start
    ))
  end
end

puzzleData['baking-bread-357627'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/baking-bread-357627-5120x3840.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/baking-bread-357627-150x113.jpg',
  resolution = '5120x3840',
  size = 4.2,
  --sourceUrl = 'https://www.pexels.com/photo/bake-bakery-baking-bread-357627/',
  templateId = 'fk4x3-16x12'
}
puzzleData['graffiti-569265'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/graffiti-569265-3264x2448.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/graffiti-569265-150x113.jpg',
  resolution = '3264x2448',
  size = 3.2,
  --sourceUrl = 'https://pixabay.com/photos/graffiti-wall-mural-painting-arts-569265/',
  templateId = 'fk4x3-24x18'
}
puzzleData['feather-1476011'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/feather-1476011-8192x6144.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/feather-1476011-150x113.jpg',
  resolution = '8192x6144',
  size = 21.7,
  --sourceUrl = 'https://pixabay.com/illustrations/feather-fractal-artistic-design-1476011/',
  templateId = 'fk4x3-24x18'
}

puzzleData['graffiti-door-1410006'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/graffiti-door-1410006-3635x2908.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/graffiti-door-1410006-150x120.jpg',
  resolution = '3635x2908',
  size = 4.2,
  --sourceUrl = 'https://pxhere.com/en/photo/1410006',
  templateId = 'fk5x4-20x16'
}
puzzleData['spice-kitchen-1162194'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/spice-kitchen-1162194-4013x3210.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/spice-kitchen-1162194-150x120.jpg',
  resolution = '4013x3210',
  size = 5.9,
  --sourceUrl = 'https://pxhere.com/en/photo/1162194',
  templateId = 'fk4x3-24x18'
}

puzzleData['BigBuckBunny'] = {
  url = 'http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/BigBuckBunny-150x84.jpg',
  resolution = '1280x720',
  size = 150,
  --sourceUrl = 'https://peach.blender.org/',
  templateId = 'fk16x9-16x9'
}
puzzleData['city-3378773'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/city-3378773-6000x3375.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/city-3378773-150x84.jpg',
  resolution = '6000x3375',
  size = 11.5,
  --sourceUrl = 'https://pixabay.com/photos/city-houses-small-town-architecture-3378773/',
  templateId = 'fk16x9-48x27'
}
puzzleData['rock-pebble-540831'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/rock-pebble-540831-10000x5625.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/rock-pebble-540831-150x84.jpg',
  resolution = '10000x5625',
  size = 13.4,
  --sourceUrl = 'https://pxhere.com/en/photo/540831',
  templateId = 'fk16x9-64x36'
}

puzzleData['heart-line-color-910338'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/heart-line-color-910338-4000x2500.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/heart-line-color-910338-150x94.jpg',
  resolution = '4000x2500',
  size = 2.2,
  --sourceUrl = 'https://pxhere.com/en/photo/910338',
  templateId = 'fk16x9-8x5'
}
puzzleData['lost-places-2759275'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/lost-places-2759275-5943x3714.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/lost-places-2759275-150x94.jpg',
  resolution = '5943x3714',
  size = 10.8,
  --sourceUrl = 'https://pixabay.com/photos/lost-places-heiligendam-villa-ruin-2759275/',
  templateId = 'fk16x9-32x18'
}
puzzleData['food-vendor-759704'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/food-vendor-759704-7360x4600.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/food-vendor-759704-150x94.jpg',
  resolution = '7360x4600',
  size = 8,
  --sourceUrl = 'https://pxhere.com/en/photo/759704',
  templateId = 'fk16x9-32x18'
}
puzzleData['china-2790936'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/china-2790936-9818x6136.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/china-2790936-150x94.jpg',
  resolution = '9818x6136',
  size = 18.1,
  --sourceUrl = 'https://pixabay.com/photos/china-old-town-child-2790936/',
  templateId = 'fk16x9-32x18'
}

puzzleData['earth-162611'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/earth-162611-2098x2797.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/earth-162611-113x150.jpg',
  resolution = '2098x2797',
  size = 0.7,
  --sourceUrl = 'https://www.jpl.nasa.gov/visions-of-the-future/',
  templateId = 'fk3x4-12x16'
}
puzzleData['space-5239295'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/space-5239295-6300x8400.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/space-5239295-113x150.jpg',
  resolution = '6300x8400',
  size = 7.3,
  --sourceUrl = 'https://pixabay.com/illustrations/space-astronaut-earth-universe-5239295/',
  templateId = 'fk3x4-27x36'
}


puzzleData['church-mountains-1444413'] = {
  url = 'https://drive.brainsick.com/tts/jigsaw-pictures/church-mountains-1444413-5715x7144.jpg',
  thumbnail = 'https://drive.brainsick.com/tts/jigsaw-pictures/church-mountains-1444413-120x150.jpg',
  resolution = '5715x7144',
  size = 17.1,
  --sourceUrl = 'https://pxhere.com/en/photo/1444413',
  templateId = 'fk4x5-24x30'
}



templateData['jg16x9-8x5'] = {dimensions = {width=8, height=5}, size=59571, seed=17, ratio='16x9'}
templateData['jg16x9-16x9'] = {dimensions = {width=16, height=9}, size=231385, seed=18, ratio='16x9'}
templateData['jg16x9-23x13'] = {dimensions = {width=23, height=13}, size=492436, seed=19, ratio='16x9'}
templateData['jg16x9-32x18'] = {dimensions = {width=32, height=18}, size=972650, seed=20, ratio='16x9'}
templateData['jg16x9-48x27'] = {dimensions = {width=48, height=27}, size=2216814, seed=21, ratio='16x9'}
templateData['jg16x9-64x36'] = {dimensions = {width=64, height=36}, size=4012483, seed=22, ratio='16x9'}
templateData['jg16x9-80x45'] = {dimensions = {width=80, height=45}, size=6279935, seed=23, ratio='16x9'}
templateData['jg16x9-96x54'] = {dimensions = {width=96, height=54}, size=9086710, seed=24, ratio='16x9'}
templateData['jg3x2-6x4'] = {dimensions = {width=6, height=4}, size=34190, seed=49, ratio='3x2'}
templateData['jg3x2-12x8'] = {dimensions = {width=12, height=8}, size=151535, seed=50, ratio='3x2'}
templateData['jg3x2-21x14'] = {dimensions = {width=21, height=14}, size=483913, seed=51, ratio='3x2'}
templateData['jg3x2-36x24'] = {dimensions = {width=36, height=24}, size=1469318, seed=52, ratio='3x2'}
templateData['jg3x2-48x32'] = {dimensions = {width=48, height=32}, size=2663223, seed=53, ratio='3x2'}
templateData['jg3x2-57x38'] = {dimensions = {width=57, height=38}, size=3774130, seed=54, ratio='3x2'}
templateData['jg3x2-66x44'] = {dimensions = {width=66, height=44}, size=5068454, seed=55, ratio='3x2'}
templateData['jg3x2-78x52'] = {dimensions = {width=78, height=52}, size=7099865, seed=56, ratio='3x2'}
templateData['jg4x3-4x3'] = {dimensions = {width=4, height=3}, size=15540, seed=57, ratio='4x3'}
templateData['jg4x3-12x9'] = {dimensions = {width=12, height=9}, size=171546, seed=58, ratio='4x3'}
templateData['jg4x3-16x12'] = {dimensions = {width=16, height=12}, size=311744, seed=59, ratio='4x3'}
templateData['jg4x3-24x18'] = {dimensions = {width=24, height=18}, size=718479, seed=60, ratio='4x3'}
templateData['jg4x3-36x27'] = {dimensions = {width=36, height=27}, size=1657324, seed=61, ratio='4x3'}
templateData['jg4x3-48x36'] = {dimensions = {width=48, height=36}, size=2999992, seed=62, ratio='4x3'}
templateData['jg4x3-60x45'] = {dimensions = {width=60, height=45}, size=4700068, seed=63, ratio='4x3'}
templateData['jg4x3-72x54'] = {dimensions = {width=72, height=54}, size=6802303, seed=64, ratio='4x3'}
templateData['jg5x4-5x4'] = {dimensions = {width=5, height=4}, size=27903, seed=9, ratio='5x4'}
templateData['jg5x4-10x8'] = {dimensions = {width=10, height=8}, size=124633, seed=10, ratio='5x4'}
templateData['jg5x4-20x16'] = {dimensions = {width=20, height=16}, size=526426, seed=11, ratio='5x4'}
templateData['jg5x4-30x24'] = {dimensions = {width=30, height=24}, size=1206901, seed=12, ratio='5x4'}
templateData['jg5x4-40x32'] = {dimensions = {width=40, height=32}, size=2206895, seed=13, ratio='5x4'}
templateData['jg5x4-50x40'] = {dimensions = {width=50, height=40}, size=3451831, seed=14, ratio='5x4'}
templateData['jg5x4-60x48'] = {dimensions = {width=60, height=48}, size=5020388, seed=15, ratio='5x4'}
templateData['jg5x4-70x56'] = {dimensions = {width=70, height=56}, size=6855277, seed=16, ratio='5x4'}
templateData['jg4x4-4x4'] = {dimensions = {width=4, height=4}, size=21957, seed=25, ratio='4x4'}
templateData['jg4x4-8x8'] = {dimensions = {width=8, height=8}, size=98902, seed=26, ratio='4x4'}
templateData['jg4x4-12x12'] = {dimensions = {width=12, height=12}, size=231688, seed=27, ratio='4x4'}
templateData['jg4x4-20x20'] = {dimensions = {width=20, height=20}, size=660651, seed=28, ratio='4x4'}
templateData['jg4x4-30x30'] = {dimensions = {width=30, height=30}, size=1513144, seed=29, ratio='4x4'}
templateData['jg4x4-40x40'] = {dimensions = {width=40, height=40}, size=2757755, seed=30, ratio='4x4'}
templateData['jg4x4-50x50'] = {dimensions = {width=50, height=50}, size=4319636, seed=31, ratio='4x4'}
templateData['jg4x4-70x70'] = {dimensions = {width=70, height=70}, size=8576198, seed=32, ratio='4x4'}
templateData['jg4x5-4x5'] = {dimensions = {width=4, height=5}, size=28054, seed=65, ratio='4x5'}
templateData['jg4x5-8x10'] = {dimensions = {width=8, height=10}, size=124641, seed=66, ratio='4x5'}
templateData['jg4x5-16x20'] = {dimensions = {width=16, height=20}, size=526113, seed=67, ratio='4x5'}
templateData['jg4x5-24x30'] = {dimensions = {width=24, height=30}, size=1206815, seed=68, ratio='4x5'}
templateData['jg4x5-32x40'] = {dimensions = {width=32, height=40}, size=2209080, seed=69, ratio='4x5'}
templateData['jg4x5-40x50'] = {dimensions = {width=40, height=50}, size=3452254, seed=70, ratio='4x5'}
templateData['jg4x5-48x60'] = {dimensions = {width=48, height=60}, size=5017725, seed=71, ratio='4x5'}
templateData['jg4x5-56x70'] = {dimensions = {width=56, height=70}, size=6853808, seed=72, ratio='4x5'}
templateData['jg3x4-3x4'] = {dimensions = {width=3, height=4}, size=15645, seed=33, ratio='3x4'}
templateData['jg3x4-9x12'] = {dimensions = {width=9, height=12}, size=171687, seed=34, ratio='3x4'}
templateData['jg3x4-12x16'] = {dimensions = {width=12, height=16}, size=311800, seed=35, ratio='3x4'}
templateData['jg3x4-18x24'] = {dimensions = {width=18, height=24}, size=718192, seed=36, ratio='3x4'}
templateData['jg3x4-27x36'] = {dimensions = {width=27, height=36}, size=1658162, seed=37, ratio='3x4'}
templateData['jg3x4-36x48'] = {dimensions = {width=36, height=48}, size=3000216, seed=38, ratio='3x4'}
templateData['jg3x4-45x60'] = {dimensions = {width=45, height=60}, size=4701020, seed=39, ratio='3x4'}
templateData['jg3x4-54x72'] = {dimensions = {width=54, height=72}, size=6805000, seed=40, ratio='3x4'}
templateData['jg2x3-4x6'] = {dimensions = {width=4, height=6}, size=34275, seed=41, ratio='2x3'}
templateData['jg2x3-8x12'] = {dimensions = {width=8, height=12}, size=151688, seed=42, ratio='2x3'}
templateData['jg2x3-14x21'] = {dimensions = {width=14, height=21}, size=483926, seed=43, ratio='2x3'}
templateData['jg2x3-24x36'] = {dimensions = {width=24, height=36}, size=1471011, seed=44, ratio='2x3'}
templateData['jg2x3-32x48'] = {dimensions = {width=32, height=48}, size=2663119, seed=45, ratio='2x3'}
templateData['jg2x3-38x57'] = {dimensions = {width=38, height=57}, size=3771612, seed=46, ratio='2x3'}
templateData['jg2x3-44x66'] = {dimensions = {width=44, height=66}, size=5069113, seed=47, ratio='2x3'}
templateData['jg2x3-52x78'] = {dimensions = {width=52, height=78}, size=7101421, seed=48, ratio='2x3'}
templateData['jg9x16-5x8'] = {dimensions = {width=5, height=8}, size=59477, seed=1, ratio='9x16'}
templateData['jg9x16-9x16'] = {dimensions = {width=9, height=16}, size=231433, seed=2, ratio='9x16'}
templateData['jg9x16-13x23'] = {dimensions = {width=13, height=23}, size=493088, seed=3, ratio='9x16'}
templateData['jg9x16-18x32'] = {dimensions = {width=18, height=32}, size=972249, seed=4, ratio='9x16'}
templateData['jg9x16-27x48'] = {dimensions = {width=27, height=48}, size=2215225, seed=5, ratio='9x16'}
templateData['jg9x16-36x64'] = {dimensions = {width=36, height=64}, size=4011571, seed=6, ratio='9x16'}
templateData['jg9x16-45x80'] = {dimensions = {width=45, height=80}, size=6280405, seed=7, ratio='9x16'}
templateData['jg9x16-54x96'] = {dimensions = {width=54, height=96}, size=9083320, seed=8, ratio='9x16'}

templateData['fk16x9-8x5'] = {dimensions = {width=8, height=5}, size=151594, seed=1, ratio='16x9'}
templateData['fk16x9-16x9'] = {dimensions = {width=16, height=9}, size=591152, seed=2, ratio='16x9'}
templateData['fk16x9-23x13'] = {dimensions = {width=23, height=13}, size=1262379, seed=3, ratio='16x9'}
templateData['fk16x9-32x18'] = {dimensions = {width=32, height=18}, size=2499478, seed=4, ratio='16x9'}
templateData['fk16x9-48x27'] = {dimensions = {width=48, height=27}, size=5699702, seed=5, ratio='16x9'}
templateData['fk16x9-64x36'] = {dimensions = {width=64, height=36}, size=10333620, seed=6, ratio='16x9'}
templateData['fk16x9-80x45'] = {dimensions = {width=80, height=45}, size=16209602, seed=7, ratio='16x9'}
templateData['fk16x9-96x54'] = {dimensions = {width=96, height=54}, size=23430487, seed=8, ratio='16x9'}
templateData['fk3x2-6x4'] = {dimensions = {width=6, height=4}, size=85559, seed=9, ratio='3x2'}
templateData['fk3x2-12x8'] = {dimensions = {width=12, height=8}, size=387842, seed=10, ratio='3x2'}
templateData['fk3x2-21x14'] = {dimensions = {width=21, height=14}, size=1241947, seed=11, ratio='3x2'}
templateData['fk3x2-36x24'] = {dimensions = {width=36, height=24}, size=3781070, seed=12, ratio='3x2'}
templateData['fk3x2-48x32'] = {dimensions = {width=48, height=32}, size=6860105, seed=13, ratio='3x2'}
templateData['fk3x2-57x38'] = {dimensions = {width=57, height=38}, size=9713411, seed=14, ratio='3x2'}
templateData['fk3x2-66x44'] = {dimensions = {width=66, height=44}, size=13050886, seed=15, ratio='3x2'}
templateData['fk3x2-78x52'] = {dimensions = {width=78, height=52}, size=18299332, seed=16, ratio='3x2'}
templateData['fk4x3-4x3'] = {dimensions = {width=4, height=3}, size=38494, seed=17, ratio='4x3'}
templateData['fk4x3-12x9'] = {dimensions = {width=12, height=9}, size=438021, seed=18, ratio='4x3'}
templateData['fk4x3-16x12'] = {dimensions = {width=16, height=12}, size=800158, seed=19, ratio='4x3'}
templateData['fk4x3-24x18'] = {dimensions = {width=24, height=18}, size=1841561, seed=20, ratio='4x3'}
templateData['fk4x3-36x27'] = {dimensions = {width=36, height=27}, size=4266868, seed=21, ratio='4x3'}
templateData['fk4x3-48x36'] = {dimensions = {width=48, height=36}, size=7728606, seed=22, ratio='4x3'}
templateData['fk4x3-60x45'] = {dimensions = {width=60, height=45}, size=12133995, seed=23, ratio='4x3'}
templateData['fk4x3-72x54'] = {dimensions = {width=72, height=54}, size=17527251, seed=24, ratio='4x3'}
templateData['fk5x4-5x4'] = {dimensions = {width=5, height=4}, size=70581, seed=25, ratio='5x4'}
templateData['fk5x4-10x8'] = {dimensions = {width=10, height=8}, size=319983, seed=26, ratio='5x4'}
templateData['fk5x4-20x16'] = {dimensions = {width=20, height=16}, size=1354400, seed=27, ratio='5x4'}
templateData['fk5x4-30x24'] = {dimensions = {width=30, height=24}, size=3110234, seed=28, ratio='5x4'}
templateData['fk5x4-40x32'] = {dimensions = {width=40, height=32}, size=5702523, seed=29, ratio='5x4'}
templateData['fk5x4-50x40'] = {dimensions = {width=50, height=40}, size=8958076, seed=30, ratio='5x4'}
templateData['fk5x4-60x48'] = {dimensions = {width=60, height=48}, size=12947351, seed=31, ratio='5x4'}
templateData['fk5x4-70x56'] = {dimensions = {width=70, height=56}, size=17674214, seed=32, ratio='5x4'}
templateData['fk4x4-4x4'] = {dimensions = {width=4, height=4}, size=54555, seed=33, ratio='4x4'}
templateData['fk4x4-8x8'] = {dimensions = {width=8, height=8}, size=252881, seed=34, ratio='4x4'}
templateData['fk4x4-12x12'] = {dimensions = {width=12, height=12}, size=594216, seed=35, ratio='4x4'}
templateData['fk4x4-20x20'] = {dimensions = {width=20, height=20}, size=1702543, seed=36, ratio='4x4'}
templateData['fk4x4-30x30'] = {dimensions = {width=30, height=30}, size=3900773, seed=37, ratio='4x4'}
templateData['fk4x4-40x40'] = {dimensions = {width=40, height=40}, size=7148141, seed=38, ratio='4x4'}
templateData['fk4x4-50x50'] = {dimensions = {width=50, height=50}, size=11229620, seed=39, ratio='4x4'}
templateData['fk4x4-70x70'] = {dimensions = {width=70, height=70}, size=22147799, seed=40, ratio='4x4'}
templateData['fk4x5-4x5'] = {dimensions = {width=4, height=5}, size=70357, seed=41, ratio='4x5'}
templateData['fk4x5-8x10'] = {dimensions = {width=8, height=10}, size=318679, seed=42, ratio='4x5'}
templateData['fk4x5-16x20'] = {dimensions = {width=16, height=20}, size=1355408, seed=43, ratio='4x5'}
templateData['fk4x5-24x30'] = {dimensions = {width=24, height=30}, size=3113884, seed=44, ratio='4x5'}
templateData['fk4x5-32x40'] = {dimensions = {width=32, height=40}, size=5703460, seed=45, ratio='4x5'}
templateData['fk4x5-40x50'] = {dimensions = {width=40, height=50}, size=8957340, seed=46, ratio='4x5'}
templateData['fk4x5-48x60'] = {dimensions = {width=48, height=60}, size=12951768, seed=47, ratio='4x5'}
templateData['fk4x5-56x70'] = {dimensions = {width=56, height=70}, size=17674654, seed=48, ratio='4x5'}
templateData['fk3x4-3x4'] = {dimensions = {width=3, height=4}, size=38493, seed=49, ratio='3x4'}
templateData['fk3x4-9x12'] = {dimensions = {width=9, height=12}, size=437007, seed=50, ratio='3x4'}
templateData['fk3x4-12x16'] = {dimensions = {width=12, height=16}, size=799277, seed=51, ratio='3x4'}
templateData['fk3x4-18x24'] = {dimensions = {width=18, height=24}, size=1844388, seed=52, ratio='3x4'}
templateData['fk3x4-27x36'] = {dimensions = {width=27, height=36}, size=4270627, seed=53, ratio='3x4'}
templateData['fk3x4-36x48'] = {dimensions = {width=36, height=48}, size=7734104, seed=54, ratio='3x4'}
templateData['fk3x4-45x60'] = {dimensions = {width=45, height=60}, size=12139266, seed=55, ratio='3x4'}
templateData['fk3x4-54x72'] = {dimensions = {width=54, height=72}, size=17536948, seed=56, ratio='3x4'}
templateData['fk2x3-4x6'] = {dimensions = {width=4, height=6}, size=85375, seed=57, ratio='2x3'}
templateData['fk2x3-8x12'] = {dimensions = {width=8, height=12}, size=386150, seed=58, ratio='2x3'}
templateData['fk2x3-14x21'] = {dimensions = {width=14, height=21}, size=1239810, seed=59, ratio='2x3'}
templateData['fk2x3-24x36'] = {dimensions = {width=24, height=36}, size=3781385, seed=60, ratio='2x3'}
templateData['fk2x3-32x48'] = {dimensions = {width=32, height=48}, size=6859633, seed=61, ratio='2x3'}
templateData['fk2x3-38x57'] = {dimensions = {width=38, height=57}, size=9712871, seed=62, ratio='2x3'}
templateData['fk2x3-44x66'] = {dimensions = {width=44, height=66}, size=13051565, seed=63, ratio='2x3'}
templateData['fk2x3-52x78'] = {dimensions = {width=52, height=78}, size=18295573, seed=64, ratio='2x3'}
templateData['fk9x16-5x8'] = {dimensions = {width=5, height=8}, size=151676, seed=65, ratio='9x16'}
templateData['fk9x16-9x16'] = {dimensions = {width=9, height=16}, size=591754, seed=66, ratio='9x16'}
templateData['fk9x16-13x23'] = {dimensions = {width=13, height=23}, size=1262887, seed=67, ratio='9x16'}
templateData['fk9x16-18x32'] = {dimensions = {width=18, height=32}, size=2503772, seed=68, ratio='9x16'}
templateData['fk9x16-27x48'] = {dimensions = {width=27, height=48}, size=5709526, seed=69, ratio='9x16'}
templateData['fk9x16-36x64'] = {dimensions = {width=36, height=64}, size=10329904, seed=70, ratio='9x16'}
templateData['fk9x16-45x80'] = {dimensions = {width=45, height=80}, size=16218605, seed=71, ratio='9x16'}
templateData['fk9x16-54x96'] = {dimensions = {width=54, height=96}, size=23418466, seed=72, ratio='9x16'}

templateData['ca16x9-8x5'] = {dimensions = {width=8, height=5}, size=195488, seed=1, ratio='16x9'}
templateData['ca16x9-16x9'] = {dimensions = {width=16, height=9}, size=768738, seed=2, ratio='16x9'}
templateData['ca16x9-23x13'] = {dimensions = {width=23, height=13}, size=1641104, seed=3, ratio='16x9'}
templateData['ca16x9-32x18'] = {dimensions = {width=32, height=18}, size=3255574, seed=4, ratio='16x9'}
templateData['ca16x9-48x27'] = {dimensions = {width=48, height=27}, size=7436725, seed=5, ratio='16x9'}
templateData['ca16x9-64x36'] = {dimensions = {width=64, height=36}, size=13469966, seed=6, ratio='16x9'}
templateData['ca16x9-80x45'] = {dimensions = {width=80, height=45}, size=21115493, seed=7, ratio='16x9'}
templateData['ca16x9-96x54'] = {dimensions = {width=96, height=54}, size=30520788, seed=8, ratio='16x9'}
templateData['ca3x2-6x4'] = {dimensions = {width=6, height=4}, size=111115, seed=9, ratio='3x2'}
templateData['ca3x2-12x8'] = {dimensions = {width=12, height=8}, size=502870, seed=10, ratio='3x2'}
templateData['ca3x2-21x14'] = {dimensions = {width=21, height=14}, size=1616102, seed=11, ratio='3x2'}
templateData['ca3x2-36x24'] = {dimensions = {width=36, height=24}, size=4929607, seed=12, ratio='3x2'}
templateData['ca3x2-48x32'] = {dimensions = {width=48, height=32}, size=8936034, seed=13, ratio='3x2'}
templateData['ca3x2-57x38'] = {dimensions = {width=57, height=38}, size=12660382, seed=14, ratio='3x2'}
templateData['ca3x2-66x44'] = {dimensions = {width=66, height=44}, size=17018098, seed=15, ratio='3x2'}
templateData['ca3x2-78x52'] = {dimensions = {width=78, height=52}, size=23846324, seed=16, ratio='3x2'}
templateData['ca4x3-4x3'] = {dimensions = {width=4, height=3}, size=49324, seed=17, ratio='4x3'}
templateData['ca4x3-12x9'] = {dimensions = {width=12, height=9}, size=569738, seed=18, ratio='4x3'}
templateData['ca4x3-16x12'] = {dimensions = {width=16, height=12}, size=1040526, seed=19, ratio='4x3'}
templateData['ca4x3-24x18'] = {dimensions = {width=24, height=18}, size=2402005, seed=20, ratio='4x3'}
templateData['ca4x3-36x27'] = {dimensions = {width=36, height=27}, size=5558292, seed=21, ratio='4x3'}
templateData['ca4x3-48x36'] = {dimensions = {width=48, height=36}, size=10072534, seed=22, ratio='4x3'}
templateData['ca4x3-60x45'] = {dimensions = {width=60, height=45}, size=15798025, seed=23, ratio='4x3'}
templateData['ca4x3-72x54'] = {dimensions = {width=72, height=54}, size=22853130, seed=24, ratio='4x3'}
templateData['ca5x4-5x4'] = {dimensions = {width=5, height=4}, size=90848, seed=25, ratio='5x4'}
templateData['ca5x4-10x8'] = {dimensions = {width=10, height=8}, size=414131, seed=26, ratio='5x4'}
templateData['ca5x4-20x16'] = {dimensions = {width=20, height=16}, size=1762595, seed=27, ratio='5x4'}
templateData['ca5x4-30x24'] = {dimensions = {width=30, height=24}, size=4047384, seed=28, ratio='5x4'}
templateData['ca5x4-40x32'] = {dimensions = {width=40, height=32}, size=7423215, seed=29, ratio='5x4'}
templateData['ca5x4-50x40'] = {dimensions = {width=50, height=40}, size=11638367, seed=30, ratio='5x4'}
templateData['ca5x4-60x48'] = {dimensions = {width=60, height=48}, size=16870353, seed=31, ratio='5x4'}
templateData['ca5x4-70x56'] = {dimensions = {width=70, height=56}, size=23039204, seed=32, ratio='5x4'}
templateData['ca4x4-4x4'] = {dimensions = {width=4, height=4}, size=70709, seed=33, ratio='4x4'}
templateData['ca4x4-8x8'] = {dimensions = {width=8, height=8}, size=327321, seed=34, ratio='4x4'}
templateData['ca4x4-12x12'] = {dimensions = {width=12, height=12}, size=771706, seed=35, ratio='4x4'}
templateData['ca4x4-20x20'] = {dimensions = {width=20, height=20}, size=2215424, seed=36, ratio='4x4'}
templateData['ca4x4-30x30'] = {dimensions = {width=30, height=30}, size=5077113, seed=37, ratio='4x4'}
templateData['ca4x4-40x40'] = {dimensions = {width=40, height=40}, size=9300725, seed=38, ratio='4x4'}
templateData['ca4x4-50x50'] = {dimensions = {width=50, height=50}, size=14559879, seed=39, ratio='4x4'}
templateData['ca4x4-70x70'] = {dimensions = {width=70, height=70}, size=28829596, seed=40, ratio='4x4'}
templateData['ca4x5-4x5'] = {dimensions = {width=4, height=5}, size=90617, seed=41, ratio='4x5'}
templateData['ca4x5-8x10'] = {dimensions = {width=8, height=10}, size=414412, seed=42, ratio='4x5'}
templateData['ca4x5-16x20'] = {dimensions = {width=16, height=20}, size=1762586, seed=43, ratio='4x5'}
templateData['ca4x5-24x30'] = {dimensions = {width=24, height=30}, size=4046715, seed=44, ratio='4x5'}
templateData['ca4x5-32x40'] = {dimensions = {width=32, height=40}, size=7423473, seed=45, ratio='4x5'}
templateData['ca4x5-40x50'] = {dimensions = {width=40, height=50}, size=11639323, seed=46, ratio='4x5'}
templateData['ca4x5-48x60'] = {dimensions = {width=48, height=60}, size=16870768, seed=47, ratio='4x5'}
templateData['ca4x5-56x70'] = {dimensions = {width=56, height=70}, size=23037103, seed=48, ratio='4x5'}
templateData['ca3x4-3x4'] = {dimensions = {width=3, height=4}, size=49621, seed=49, ratio='3x4'}
templateData['ca3x4-9x12'] = {dimensions = {width=9, height=12}, size=569589, seed=50, ratio='3x4'}
templateData['ca3x4-12x16'] = {dimensions = {width=12, height=16}, size=1040158, seed=51, ratio='3x4'}
templateData['ca3x4-18x24'] = {dimensions = {width=18, height=24}, size=2402103, seed=52, ratio='3x4'}
templateData['ca3x4-27x36'] = {dimensions = {width=27, height=36}, size=5558530, seed=53, ratio='3x4'}
templateData['ca3x4-36x48'] = {dimensions = {width=36, height=48}, size=10073772, seed=54, ratio='3x4'}
templateData['ca3x4-45x60'] = {dimensions = {width=45, height=60}, size=15798122, seed=55, ratio='3x4'}
templateData['ca3x4-54x72'] = {dimensions = {width=54, height=72}, size=22853139, seed=56, ratio='3x4'}
templateData['ca2x3-4x6'] = {dimensions = {width=4, height=6}, size=111090, seed=57, ratio='2x3'}
templateData['ca2x3-8x12'] = {dimensions = {width=8, height=12}, size=502637, seed=58, ratio='2x3'}
templateData['ca2x3-14x21'] = {dimensions = {width=14, height=21}, size=1616247, seed=59, ratio='2x3'}
templateData['ca2x3-24x36'] = {dimensions = {width=24, height=36}, size=4927151, seed=60, ratio='2x3'}
templateData['ca2x3-32x48'] = {dimensions = {width=32, height=48}, size=8935668, seed=61, ratio='2x3'}
templateData['ca2x3-38x57'] = {dimensions = {width=38, height=57}, size=12660440, seed=62, ratio='2x3'}
templateData['ca2x3-44x66'] = {dimensions = {width=44, height=66}, size=17014076, seed=63, ratio='2x3'}
templateData['ca2x3-52x78'] = {dimensions = {width=52, height=78}, size=23845937, seed=64, ratio='2x3'}
templateData['ca9x16-5x8'] = {dimensions = {width=5, height=8}, size=195964, seed=65, ratio='9x16'}
templateData['ca9x16-9x16'] = {dimensions = {width=9, height=16}, size=767328, seed=66, ratio='9x16'}
templateData['ca9x16-13x23'] = {dimensions = {width=13, height=23}, size=1642195, seed=67, ratio='9x16'}
templateData['ca9x16-18x32'] = {dimensions = {width=18, height=32}, size=3256587, seed=68, ratio='9x16'}
templateData['ca9x16-27x48'] = {dimensions = {width=27, height=48}, size=7439222, seed=69, ratio='9x16'}
templateData['ca9x16-36x64'] = {dimensions = {width=36, height=64}, size=13465725, seed=70, ratio='9x16'}
templateData['ca9x16-45x80'] = {dimensions = {width=45, height=80}, size=21118377, seed=71, ratio='9x16'}
templateData['ca9x16-54x96'] = {dimensions = {width=54, height=96}, size=30525874, seed=72, ratio='9x16'}



for lbl, details in pairs(templateData) do
  details.size = details.size/1000000
  details.baseUrl = PUZZLE_URL .. string.sub(lbl,1,2) .. '/' .. lbl .. '/'
end

pieceTypeList = {}
pieceTypeList['ca'] = {name = "Casual", description = "Made for the laid back puzzler"}
pieceTypeList['fk'] = {name = "Funky", description = "Funky pieces that have many interesting features"}
pieceTypeList['jg'] = {name = "Spikey", description = "Small, simple and to the pointy"}
